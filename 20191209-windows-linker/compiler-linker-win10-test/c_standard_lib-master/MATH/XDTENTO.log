
#####==========stderr_mid==========#####:
In file included from ./c_standard_lib-master/MATH/XDTENTO.c:2:
In file included from ./c_standard_lib-master/_HEADERS\errno.h:5:
./c_standard_lib-master/_HEADERS\yvals.h:35:5: warning: declaration of built-in function 'setjmp' requires inclusion of the header <setjmp.h> [-Wbuiltin-requires-header]
int setjmp(int *);
    ^
'' is not a recognized processor for this target (ignoring processor)
1 warning generated.

#####==========stderr_asm==========#####:
Pass Arguments:  -targetlibinfo -datalayout -jump-instr-table-info -notti -basictti -targetpassconfig -no-aa -tbaa -basicaa -collector-metadata -machinemoduleinfo -machine-branch-prob -jump-instr-tables -verify -verify-di -domtree -loops -loop-simplify -scalar-evolution -iv-users -loop-reduce -gc-lowering -unreachableblockelim -consthoist -codegenprepare -verify-di -stack-protector -verify -domtree -loops -branch-prob -expand-isel-pseudos -tailduplication -opt-phis -machinedomtree -slotindexes -stack-coloring -localstackalloc -dead-mi-elimination -machinedomtree -machine-loops -machinelicm -machine-cse -machine-sink -peephole-opts -machinedomtree -machine-loops -hwloops -processimpdefs -unreachable-mbb-elimination -livevars -machinedomtree -machine-loops -phi-node-elimination -twoaddressinstruction -slotindexes -liveintervals -simple-register-coalescing -machine-block-freq -livedebugvars -livestacks -virtregmap -liveregmatrix -edge-bundles -spill-code-placement -virtregrewriter -stack-slot-coloring -machinelicm -prologepilog -branch-folder -tailduplication -machine-cp -postrapseudos -machinedomtree -machine-loops -post-RA-sched -gc-analysis -machine-block-freq -block-placement2 -machinedomtree -machine-loops -packets -hwloopsfixup -stackmap-liveness
Target Library Information
Data Layout
Jump-Instruction Table Info
No target information
Target independent code generator's TTI
Target Pass Configuration
No Alias Analysis (always returns 'may' alias)
Type-Based Alias Analysis
Basic Alias Analysis (stateless AA impl)
Create Garbage Collector Module Metadata
Machine Module Information
Machine Branch Probability Analysis
  ModulePass Manager
    Jump-Instruction Tables
    FunctionPass Manager
      Module Verifier
    Debug Info Verifier
    FunctionPass Manager
      Dominator Tree Construction
      Natural Loop Information
      Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Induction Variable Users
        Loop Strength Reduction
      Lower Garbage Collection Instructions
      Remove unreachable blocks from the CFG
      Constant Hoisting
      CodeGen Prepare
      Exception handling preparation
    Debug Info Verifier
    FunctionPass Manager
      Insert stack protectors
      Module Verifier
      Machine Function Analysis
      Dominator Tree Construction
      Natural Loop Information
      Branch Probability Analysis
      DSP DAG->DAG Pattern Instruction Selection
      Expand ISel Pseudo-instructions
      Tail Duplication
      Optimize machine instruction PHIs
      MachineDominator Tree Construction
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Loop Invariant Code Motion
      Machine Common Subexpression Elimination
      Machine code sinking
      Peephole Optimizations
      DSP handle CC
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      DSP Hardware Loops
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Eliminate PHI nodes for register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Simple Register Coalescing
      Machine Block Frequency Analysis
      Debug Variable Analysis
      Live Stack Slot Analysis
      Virtual Register Map
      Live Register Matrix
      Bundle Machine CFG Edges
      Spill Code Placement Analysis
      Greedy Register Allocator
      Virtual Register Rewriter
      Stack Slot Coloring
      Machine Loop Invariant Code Motion
      Prologue/Epilogue Insertion & Frame Finalization
      Control Flow Optimizer
      Tail Duplication
      Machine Copy Propagation Pass
      Post-RA pseudo instruction expansion pass
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Post RA top-down list latency scheduler
      Analyze Machine Code For Garbage Collection
      Machine Block Frequency Analysis
      Branch Probability Basic Block Placement
      DSP Del Useless jmp
      DSP Delay Slot Filler
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      DSP Packetizer
      DSP VLIWBundlerDrive
      DSP Hardware Loop Fixup
      StackMap Liveness Analysis
      dsp assembly printer
# Machine code for function _Dtento: SSA
Frame Objects:
  fi#-1: size=4, align=8, fixed, at location [SP+8]
  fi#0: size=8, align=8, at location [SP]
  fi#1: size=8, align=8, at location [SP]
  fi#2: size=2, align=4, at location [SP]
  fi#3: size=8, align=8, at location [SP]
  fi#4: size=2, align=4, at location [SP]
  fi#5: size=4, align=4, at location [SP]
  fi#6: size=4, align=4, at location [SP]
Function Live Ins: %A0 in %vreg4, %A1 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0 %A1
	%vreg5<def> = COPY %A1; CPURegs:%vreg5
	%vreg4<def> = COPY %A0; CPURegs:%vreg4
	%vreg6<def> = LD <fi#-1>, 0; mem:LD4[FixedStack-1](align=8) CPURegs:%vreg6
	ST %vreg5, <fi#1>, 4; mem:ST4[%x.addr+4] CPURegs:%vreg5
	ST %vreg4, <fi#1>, 0; mem:ST4[%x.addr](align=8) CPURegs:%vreg4
	STH %vreg6<kill>, <fi#2>, 0; mem:ST2[%n.addr](align=4) CPURegs:%vreg6
	%vreg7<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg7
	%vreg8<def> = EQI %vreg7<kill>, 0; CPURegs:%vreg8,%vreg7
	JC %vreg8<kill>, <BB#2>; CPURegs:%vreg8
	Jmp <BB#1>
    Successors according to CFG: BB#2(12) BB#1(20)

BB#1: derived from LLVM BB %lor.lhs.false
    Predecessors according to CFG: BB#0
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg9<def> = COPY %SP; CPURegs:%vreg9
	%vreg10<def> = MovGR %ZERO, 0; CPURegs:%vreg10
	ST %vreg10, %vreg9, 12; mem:ST4[<unknown>] CPURegs:%vreg10,%vreg9
	ST %vreg10, %vreg9, 8; mem:ST4[<unknown>] CPURegs:%vreg10,%vreg9
	%vreg11<def> = LD <fi#1>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg11
	%vreg12<def> = LD <fi#1>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg12
	%A0<def> = COPY %vreg11; CPURegs:%vreg11
	%A1<def> = COPY %vreg12; CPURegs:%vreg12
	CALL <es:__nedf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg13<def> = COPY %V0; CPURegs:%vreg13
	%vreg14<def> = NEQI %vreg13, 0; CPURegs:%vreg14,%vreg13
	JC %vreg14<kill>, <BB#3>; CPURegs:%vreg14
	Jmp <BB#2>
    Successors according to CFG: BB#2(20) BB#3(12)

BB#2: derived from LLVM BB %if.then
    Predecessors according to CFG: BB#0 BB#1
	%vreg149<def> = LD <fi#1>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg149
	%vreg150<def> = LD <fi#1>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg150
	ST %vreg150<kill>, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg150
	ST %vreg149<kill>, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg149
	Jmp <BB#34>
    Successors according to CFG: BB#34

BB#3: derived from LLVM BB %if.end
    Predecessors according to CFG: BB#1
	%vreg15<def> = MovGR %ZERO, 1072693248; CPURegs:%vreg15
	ST %vreg15<kill>, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg15
	ST %vreg10, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg10
	%vreg17<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg17
	%vreg18<def> = LTI %vreg17<kill>, 0; CPURegs:%vreg18,%vreg17
	JNC %vreg18<kill>, <BB#17>; CPURegs:%vreg18
	Jmp <BB#4>
    Successors according to CFG: BB#4(12) BB#17(20)

BB#4: derived from LLVM BB %if.then7
    Predecessors according to CFG: BB#3
	%vreg77<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg77
	%vreg78<def> = MovGR %ZERO, 0; CPURegs:%vreg78
	%vreg79<def> = SUBu %vreg78, %vreg77<kill>; CPURegs:%vreg79,%vreg78,%vreg77
	ST %vreg79<kill>, <fi#6>, 0; mem:ST4[%nu] CPURegs:%vreg79
	ST %vreg78, <fi#5>, 0; mem:ST4[%i] CPURegs:%vreg78
    Successors according to CFG: BB#5

BB#5: derived from LLVM BB %for.cond
    Predecessors according to CFG: BB#4 BB#10
	%vreg81<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg81
	%vreg82<def> = EQI %vreg81<kill>, 0; CPURegs:%vreg82,%vreg81
	JC %vreg82<kill>, <BB#7>; CPURegs:%vreg82
	Jmp <BB#6>
    Successors according to CFG: BB#6(16) BB#7(16)

BB#35: 
    Predecessors according to CFG: BB#6
	%vreg154<def> = MovGR %ZERO, 1; CPURegs:%vreg154
	Jmp <BB#7>
    Successors according to CFG: BB#7

BB#6: derived from LLVM BB %land.rhs
    Predecessors according to CFG: BB#5
	%vreg83<def> = MovGR %ZERO, 8; CPURegs:%vreg83
	%vreg84<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg84
	%vreg0<def> = LTU %vreg84<kill>, %vreg83<kill>; CPURegs:%vreg0,%vreg84,%vreg83
	%vreg153<def> = MovGR %ZERO, 0; CPURegs:%vreg153
	JNC %vreg84<kill>, <BB#7>; CPURegs:%vreg84
	Jmp <BB#35>
    Successors according to CFG: BB#7 BB#35

BB#7: derived from LLVM BB %land.end
    Predecessors according to CFG: BB#5 BB#6 BB#35
	%vreg1<def> = PHI %vreg78, <BB#5>, %vreg153, <BB#6>, %vreg154, <BB#35>; CPURegs:%vreg1,%vreg78,%vreg153,%vreg154
	%vreg85<def> = EQI %vreg1, 0; CPURegs:%vreg85,%vreg1
	JC %vreg85<kill>, <BB#11>; CPURegs:%vreg85
	Jmp <BB#8>
    Successors according to CFG: BB#8(124) BB#11(4)

BB#8: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#7
	%vreg127<def> = MovGR %ZERO, 1; CPURegs:%vreg127
	%vreg128<def> = LDBZ <fi#6>, 0; mem:LD1[%nu](align=4) CPURegs:%vreg128
	%vreg129<def> = AND %vreg128<kill>, %vreg127; CPURegs:%vreg129,%vreg128,%vreg127
	%vreg130<def> = EQI %vreg129<kill>, 0; CPURegs:%vreg130,%vreg129
	JC %vreg130<kill>, <BB#10>; CPURegs:%vreg130
	Jmp <BB#9>
    Successors according to CFG: BB#9(20) BB#10(12)

BB#9: derived from LLVM BB %if.then13
    Predecessors according to CFG: BB#8
	%vreg131<def> = MovGR %ZERO, 3; CPURegs:%vreg131
	%vreg132<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg132
	%vreg133<def> = SHL %vreg132<kill>, %vreg131<kill>; CPURegs:%vreg133,%vreg132,%vreg131
	%vreg134<def> = MovIGH %ZERO, <ga:@pows>[TF=3]; CPURegs:%vreg134
	%vreg135<def,tied1> = MovIGL %vreg134<tied0>, <ga:@pows>[TF=4]; CPURegs:%vreg135,%vreg134
	%vreg136<def> = ADDu %vreg135<kill>, %vreg133<kill>; CPURegs:%vreg136,%vreg135,%vreg133
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg137<def> = COPY %SP; CPURegs:%vreg137
	%vreg138<def> = LD %vreg136, 4; mem:LD4[%arrayidx+4] CPURegs:%vreg138,%vreg136
	ST %vreg138<kill>, %vreg137, 12; mem:ST4[<unknown>] CPURegs:%vreg138,%vreg137
	%vreg139<def> = LD %vreg136, 0; mem:LD4[%arrayidx](align=8) CPURegs:%vreg139,%vreg136
	ST %vreg139<kill>, %vreg137, 8; mem:ST4[<unknown>] CPURegs:%vreg139,%vreg137
	%vreg140<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg140
	%vreg141<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg141
	%A0<def> = COPY %vreg140; CPURegs:%vreg140
	%A1<def> = COPY %vreg141; CPURegs:%vreg141
	CALL <es:__muldf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg142<def> = COPY %V0; CPURegs:%vreg142
	%vreg143<def> = COPY %V1; CPURegs:%vreg143
	ST %vreg143, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg143
	ST %vreg142, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg142
    Successors according to CFG: BB#10

BB#10: derived from LLVM BB %for.inc
    Predecessors according to CFG: BB#8 BB#9
	%vreg145<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg145
	%vreg146<def> = SRL %vreg145<kill>, %vreg127; CPURegs:%vreg146,%vreg145,%vreg127
	ST %vreg146<kill>, <fi#6>, 0; mem:ST4[%nu] CPURegs:%vreg146
	%vreg147<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg147
	%vreg148<def> = ADDiu %vreg147<kill>, 1; CPURegs:%vreg148,%vreg147
	ST %vreg148<kill>, <fi#5>, 0; mem:ST4[%i] CPURegs:%vreg148
	Jmp <BB#5>
    Successors according to CFG: BB#5

BB#11: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#7
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg86<def> = COPY %SP; CPURegs:%vreg86
	%vreg87<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg87
	ST %vreg87<kill>, %vreg86, 12; mem:ST4[<unknown>] CPURegs:%vreg87,%vreg86
	%vreg88<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg88
	ST %vreg88<kill>, %vreg86, 8; mem:ST4[<unknown>] CPURegs:%vreg88,%vreg86
	%vreg89<def> = MovGR %ZERO, 0; CPURegs:%vreg89
	%vreg90<def> = MovGR %ZERO, 1072693248; CPURegs:%vreg90
	%A0<def> = COPY %vreg89; CPURegs:%vreg89
	%A1<def> = COPY %vreg90; CPURegs:%vreg90
	CALL <es:__divdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg91<def> = COPY %V0; CPURegs:%vreg91
	%vreg92<def> = COPY %V1; CPURegs:%vreg92
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg93<def> = COPY %SP; CPURegs:%vreg93
	ST %vreg92, %vreg93, 12; mem:ST4[<unknown>] CPURegs:%vreg92,%vreg93
	ST %vreg91, %vreg93, 8; mem:ST4[<unknown>] CPURegs:%vreg91,%vreg93
	%vreg94<def> = LEA <fi#1>, 0; CPURegs:%vreg94
	%A0<def> = COPY %vreg94; CPURegs:%vreg94
	CALL <ga:@dmul>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg95<def> = COPY %V0; CPURegs:%vreg95
	STH %vreg95, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg95
	%vreg96<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg96
	%vreg97<def> = LTI %vreg96<kill>, 0; CPURegs:%vreg97,%vreg96
	JNC %vreg97<kill>, <BB#31>; CPURegs:%vreg97
	Jmp <BB#12>
    Successors according to CFG: BB#12(12) BB#31(20)

BB#12: derived from LLVM BB %land.lhs.true
    Predecessors according to CFG: BB#11
	%vreg98<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg98
	%vreg99<def> = EQI %vreg98<kill>, 0; CPURegs:%vreg99,%vreg98
	JC %vreg99<kill>, <BB#31>; CPURegs:%vreg99
	Jmp <BB#13>
    Successors according to CFG: BB#13(16) BB#31(16)

BB#13: derived from LLVM BB %if.then20
    Predecessors according to CFG: BB#12
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg100<def> = MovIGH %ZERO, <ga:@pows>[TF=3]; CPURegs:%vreg100
	%vreg101<def,tied1> = MovIGL %vreg100<tied0>, <ga:@pows>[TF=4]; CPURegs:%vreg101,%vreg100
	%vreg102<def> = COPY %SP; CPURegs:%vreg102
	%vreg103<def> = LD %vreg101, 68; mem:LD4[getelementptr inbounds ([9 x double]* @pows, i32 0, i32 8)+4] CPURegs:%vreg103,%vreg101
	ST %vreg103<kill>, %vreg102, 12; mem:ST4[<unknown>] CPURegs:%vreg103,%vreg102
	%vreg104<def> = LD %vreg101, 64; mem:LD4[getelementptr inbounds ([9 x double]* @pows, i32 0, i32 8)](align=8) CPURegs:%vreg104,%vreg101
	ST %vreg104<kill>, %vreg102, 8; mem:ST4[<unknown>] CPURegs:%vreg104,%vreg102
	%vreg105<def> = MovGR %ZERO, 0; CPURegs:%vreg105
	%vreg106<def> = MovGR %ZERO, 1072693248; CPURegs:%vreg106
	%A0<def> = COPY %vreg105; CPURegs:%vreg105
	%A1<def> = COPY %vreg106; CPURegs:%vreg106
	CALL <es:__divdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg107<def> = COPY %V0; CPURegs:%vreg107
	%vreg108<def> = COPY %V1; CPURegs:%vreg108
	ST %vreg108, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg108
	ST %vreg107, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg107
    Successors according to CFG: BB#14

BB#14: derived from LLVM BB %for.cond22
    Predecessors according to CFG: BB#13 BB#16
	%vreg109<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg109
	%vreg110<def> = EQI %vreg109<kill>, 0; CPURegs:%vreg110,%vreg109
	JC %vreg110<kill>, <BB#31>; CPURegs:%vreg110
	Jmp <BB#15>
    Successors according to CFG: BB#15(124) BB#31(4)

BB#15: derived from LLVM BB %for.body25
    Predecessors according to CFG: BB#14
	%vreg111<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg111
	%vreg112<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg112
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg113<def> = COPY %SP; CPURegs:%vreg113
	ST %vreg112<kill>, %vreg113, 12; mem:ST4[<unknown>] CPURegs:%vreg112,%vreg113
	ST %vreg111<kill>, %vreg113, 8; mem:ST4[<unknown>] CPURegs:%vreg111,%vreg113
	%vreg114<def> = LEA <fi#1>, 0; CPURegs:%vreg114
	%A0<def> = COPY %vreg114; CPURegs:%vreg114
	CALL <ga:@dmul>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg115<def> = COPY %V0; CPURegs:%vreg115
	STH %vreg115, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg115
	%vreg116<def> = LTI %vreg115, 0; CPURegs:%vreg116,%vreg115
	JNC %vreg116<kill>, <BB#31>; CPURegs:%vreg116
	Jmp <BB#16>
    Successors according to CFG: BB#31(4) BB#16(124)

BB#16: derived from LLVM BB %for.inc32
    Predecessors according to CFG: BB#15
	%vreg117<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg117
	%vreg118<def> = ADDiu %vreg117<kill>, -1; CPURegs:%vreg118,%vreg117
	ST %vreg118<kill>, <fi#6>, 0; mem:ST4[%nu] CPURegs:%vreg118
	Jmp <BB#14>
    Successors according to CFG: BB#14

BB#17: derived from LLVM BB %if.else
    Predecessors according to CFG: BB#3
	%vreg19<def> = MovGR %ZERO, 1; CPURegs:%vreg19
	%vreg20<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg20
	%vreg21<def> = LT %vreg20<kill>, %vreg19; CPURegs:%vreg21,%vreg20,%vreg19
	JC %vreg21<kill>, <BB#31>; CPURegs:%vreg21
	Jmp <BB#18>
    Successors according to CFG: BB#18(16) BB#31(16)

BB#18: derived from LLVM BB %if.then38
    Predecessors according to CFG: BB#17
	ST %vreg10, <fi#5>, 0; mem:ST4[%i] CPURegs:%vreg10
    Successors according to CFG: BB#19

BB#19: derived from LLVM BB %for.cond39
    Predecessors according to CFG: BB#18 BB#24
	%vreg25<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg25
	%vreg26<def> = LT %vreg25<kill>, %vreg19; CPURegs:%vreg26,%vreg25,%vreg19
	JC %vreg26<kill>, <BB#21>; CPURegs:%vreg26
	Jmp <BB#20>
    Successors according to CFG: BB#20(16) BB#21(16)

BB#20: derived from LLVM BB %land.rhs43
    Predecessors according to CFG: BB#19
	%vreg27<def> = MovGR %ZERO, 8; CPURegs:%vreg27
	%vreg28<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg28
	%vreg2<def> = LTU %vreg28<kill>, %vreg27<kill>; CPURegs:%vreg2,%vreg28,%vreg27
    Successors according to CFG: BB#21

BB#21: derived from LLVM BB %land.end46
    Predecessors according to CFG: BB#19 BB#20
	%vreg3<def> = PHI %vreg10, <BB#19>, %vreg2, <BB#20>; CPURegs:%vreg3,%vreg10,%vreg2
	%vreg29<def> = EQI %vreg3, 0; CPURegs:%vreg29,%vreg3
	JC %vreg29<kill>, <BB#25>; CPURegs:%vreg29
	Jmp <BB#22>
    Successors according to CFG: BB#22(124) BB#25(4)

BB#22: derived from LLVM BB %for.body47
    Predecessors according to CFG: BB#21
	%vreg56<def> = LDBZ <fi#2>, 0; mem:LD1[%n.addr](align=4) CPURegs:%vreg56
	%vreg57<def> = AND %vreg56<kill>, %vreg19; CPURegs:%vreg57,%vreg56,%vreg19
	%vreg58<def> = EQI %vreg57<kill>, 0; CPURegs:%vreg58,%vreg57
	JC %vreg58<kill>, <BB#24>; CPURegs:%vreg58
	Jmp <BB#23>
    Successors according to CFG: BB#23(20) BB#24(12)

BB#23: derived from LLVM BB %if.then51
    Predecessors according to CFG: BB#22
	%vreg59<def> = MovGR %ZERO, 3; CPURegs:%vreg59
	%vreg60<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg60
	%vreg61<def> = SHL %vreg60<kill>, %vreg59<kill>; CPURegs:%vreg61,%vreg60,%vreg59
	%vreg62<def> = MovIGH %ZERO, <ga:@pows>[TF=3]; CPURegs:%vreg62
	%vreg63<def,tied1> = MovIGL %vreg62<tied0>, <ga:@pows>[TF=4]; CPURegs:%vreg63,%vreg62
	%vreg64<def> = ADDu %vreg63<kill>, %vreg61<kill>; CPURegs:%vreg64,%vreg63,%vreg61
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg65<def> = COPY %SP; CPURegs:%vreg65
	%vreg66<def> = LD %vreg64, 4; mem:LD4[%arrayidx52+4] CPURegs:%vreg66,%vreg64
	ST %vreg66<kill>, %vreg65, 12; mem:ST4[<unknown>] CPURegs:%vreg66,%vreg65
	%vreg67<def> = LD %vreg64, 0; mem:LD4[%arrayidx52](align=8) CPURegs:%vreg67,%vreg64
	ST %vreg67<kill>, %vreg65, 8; mem:ST4[<unknown>] CPURegs:%vreg67,%vreg65
	%vreg68<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg68
	%vreg69<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg69
	%A0<def> = COPY %vreg68; CPURegs:%vreg68
	%A1<def> = COPY %vreg69; CPURegs:%vreg69
	CALL <es:__muldf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg70<def> = COPY %V0; CPURegs:%vreg70
	%vreg71<def> = COPY %V1; CPURegs:%vreg71
	ST %vreg71, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg71
	ST %vreg70, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg70
    Successors according to CFG: BB#24

BB#24: derived from LLVM BB %for.inc55
    Predecessors according to CFG: BB#22 BB#23
	%vreg73<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg73
	%vreg74<def> = SRL %vreg73<kill>, %vreg19; CPURegs:%vreg74,%vreg73,%vreg19
	STH %vreg74<kill>, <fi#2>, 0; mem:ST2[%n.addr](align=4) CPURegs:%vreg74
	%vreg75<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg75
	%vreg76<def> = ADDiu %vreg75<kill>, 1; CPURegs:%vreg76,%vreg75
	ST %vreg76<kill>, <fi#5>, 0; mem:ST4[%i] CPURegs:%vreg76
	Jmp <BB#19>
    Successors according to CFG: BB#19

BB#25: derived from LLVM BB %for.end60
    Predecessors according to CFG: BB#21
	%vreg30<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg30
	%vreg31<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg31
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg32<def> = COPY %SP; CPURegs:%vreg32
	ST %vreg31<kill>, %vreg32, 12; mem:ST4[<unknown>] CPURegs:%vreg31,%vreg32
	ST %vreg30<kill>, %vreg32, 8; mem:ST4[<unknown>] CPURegs:%vreg30,%vreg32
	%vreg33<def> = LEA <fi#1>, 0; CPURegs:%vreg33
	%A0<def> = COPY %vreg33; CPURegs:%vreg33
	CALL <ga:@dmul>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg34<def> = COPY %V0; CPURegs:%vreg34
	STH %vreg34, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg34
	%vreg35<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg35
	%vreg36<def> = LTI %vreg35<kill>, 0; CPURegs:%vreg36,%vreg35
	JNC %vreg36<kill>, <BB#31>; CPURegs:%vreg36
	Jmp <BB#26>
    Successors according to CFG: BB#26(12) BB#31(20)

BB#26: derived from LLVM BB %land.lhs.true65
    Predecessors according to CFG: BB#25
	%vreg38<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg38
	%vreg39<def> = LT %vreg38<kill>, %vreg19; CPURegs:%vreg39,%vreg38,%vreg19
	JC %vreg39<kill>, <BB#31>; CPURegs:%vreg39
	Jmp <BB#27>
    Successors according to CFG: BB#27(16) BB#31(16)

BB#27: derived from LLVM BB %if.then69
    Predecessors according to CFG: BB#26
	%vreg40<def> = MovIGH %ZERO, <ga:@pows>[TF=3]; CPURegs:%vreg40
	%vreg41<def,tied1> = MovIGL %vreg40<tied0>, <ga:@pows>[TF=4]; CPURegs:%vreg41,%vreg40
	%vreg42<def> = LD %vreg41, 68; mem:LD4[getelementptr inbounds ([9 x double]* @pows, i32 0, i32 8)+4] CPURegs:%vreg42,%vreg41
	ST %vreg42<kill>, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg42
	%vreg43<def> = LD %vreg41, 64; mem:LD4[getelementptr inbounds ([9 x double]* @pows, i32 0, i32 8)](align=8) CPURegs:%vreg43,%vreg41
	ST %vreg43<kill>, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg43
    Successors according to CFG: BB#28

BB#28: derived from LLVM BB %for.cond70
    Predecessors according to CFG: BB#27 BB#30
	%vreg45<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg45
	%vreg46<def> = LT %vreg45<kill>, %vreg19; CPURegs:%vreg46,%vreg45,%vreg19
	JC %vreg46<kill>, <BB#31>; CPURegs:%vreg46
	Jmp <BB#29>
    Successors according to CFG: BB#29(124) BB#31(4)

BB#29: derived from LLVM BB %for.body74
    Predecessors according to CFG: BB#28
	%vreg47<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg47
	%vreg48<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg48
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg49<def> = COPY %SP; CPURegs:%vreg49
	ST %vreg48<kill>, %vreg49, 12; mem:ST4[<unknown>] CPURegs:%vreg48,%vreg49
	ST %vreg47<kill>, %vreg49, 8; mem:ST4[<unknown>] CPURegs:%vreg47,%vreg49
	%vreg50<def> = LEA <fi#1>, 0; CPURegs:%vreg50
	%A0<def> = COPY %vreg50; CPURegs:%vreg50
	CALL <ga:@dmul>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg51<def> = COPY %V0; CPURegs:%vreg51
	STH %vreg51, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg51
	%vreg52<def> = LTI %vreg51, 0; CPURegs:%vreg52,%vreg51
	JNC %vreg52<kill>, <BB#31>; CPURegs:%vreg52
	Jmp <BB#30>
    Successors according to CFG: BB#31(4) BB#30(124)

BB#30: derived from LLVM BB %for.inc81
    Predecessors according to CFG: BB#29
	%vreg53<def> = LDH <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg53
	%vreg54<def> = ADDiu %vreg53<kill>, -1; CPURegs:%vreg54,%vreg53
	STH %vreg54<kill>, <fi#2>, 0; mem:ST2[%n.addr](align=4) CPURegs:%vreg54
	Jmp <BB#28>
    Successors according to CFG: BB#28

BB#31: derived from LLVM BB %if.end86
    Predecessors according to CFG: BB#17 BB#25 BB#26 BB#28 BB#29 BB#11 BB#12 BB#14 BB#15
	%vreg119<def> = MovGR %ZERO, 0; CPURegs:%vreg119
	%vreg120<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg120
	%vreg121<def> = LT %vreg120<kill>, %vreg119<kill>; CPURegs:%vreg121,%vreg120,%vreg119
	JC %vreg121<kill>, <BB#33>; CPURegs:%vreg121
	Jmp <BB#32>
    Successors according to CFG: BB#32(16) BB#33(16)

BB#32: derived from LLVM BB %if.then90
    Predecessors according to CFG: BB#31
	%vreg122<def> = MovIGH %ZERO, <ga:@errno>[TF=3]; CPURegs:%vreg122
	%vreg123<def,tied1> = MovIGL %vreg122<tied0>, <ga:@errno>[TF=4]; CPURegs:%vreg123,%vreg122
	%vreg124<def> = MovGR %ZERO, 34; CPURegs:%vreg124
	ST %vreg124<kill>, %vreg123<kill>, 0; mem:ST4[@errno] CPURegs:%vreg124,%vreg123
    Successors according to CFG: BB#33

BB#33: derived from LLVM BB %if.end91
    Predecessors according to CFG: BB#31 BB#32
	%vreg125<def> = LD <fi#1>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg125
	%vreg126<def> = LD <fi#1>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg126
	ST %vreg126<kill>, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg126
	ST %vreg125<kill>, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg125
    Successors according to CFG: BB#34

BB#34: derived from LLVM BB %return
    Predecessors according to CFG: BB#33 BB#2
	%vreg151<def> = LD <fi#0>, 0; mem:LD4[%retval](align=8) CPURegs:%vreg151
	%vreg152<def> = LD <fi#0>, 4; mem:LD4[%retval+4] CPURegs:%vreg152
	%V0<def> = COPY %vreg151; CPURegs:%vreg151
	%V1<def> = COPY %vreg152; CPURegs:%vreg152
	RetLR %V0<imp-use>, %V1<imp-use>

# End machine code for function _Dtento.

# Machine code for function dmul: SSA
Frame Objects:
  fi#-2: size=4, align=4, fixed, at location [SP+12]
  fi#-1: size=4, align=8, fixed, at location [SP+8]
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=8, align=8, at location [SP]
  fi#2: size=2, align=4, at location [SP]
Function Live Ins: %A0 in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%vreg0<def> = COPY %A0; CPURegs:%vreg0
	%vreg1<def> = LD <fi#-1>, 0; mem:LD4[FixedStack-1](align=8) CPURegs:%vreg1
	%vreg2<def> = LD <fi#-2>, 0; mem:LD4[FixedStack-2] CPURegs:%vreg2
	ST %vreg0, <fi#0>, 0; mem:ST4[%px.addr] CPURegs:%vreg0
	ST %vreg2<kill>, <fi#1>, 4; mem:ST4[%y.addr+4] CPURegs:%vreg2
	ST %vreg1<kill>, <fi#1>, 0; mem:ST4[%y.addr](align=8) CPURegs:%vreg1
	%vreg3<def> = LD <fi#0>, 0; mem:LD4[%px.addr] CPURegs:%vreg3
	ADJCALLSTACKDOWN 8, %SP<imp-def,dead>, %SP<imp-use>
	%vreg4<def> = LEA <fi#2>, 0; CPURegs:%vreg4
	%A0<def> = COPY %vreg4; CPURegs:%vreg4
	%A1<def> = COPY %vreg3; CPURegs:%vreg3
	CALL <ga:@_Dunscale>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 8, 0, %SP<imp-def,dead>, %SP<imp-use>
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg6<def> = COPY %SP; CPURegs:%vreg6
	%vreg7<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg7
	ST %vreg7<kill>, %vreg6, 12; mem:ST4[<unknown>] CPURegs:%vreg7,%vreg6
	%vreg8<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg8
	ST %vreg8<kill>, %vreg6, 8; mem:ST4[<unknown>] CPURegs:%vreg8,%vreg6
	%vreg9<def> = LD <fi#0>, 0; mem:LD4[%px.addr] CPURegs:%vreg9
	%vreg10<def> = LD %vreg9, 0; mem:LD4[%2](align=8) CPURegs:%vreg10,%vreg9
	%vreg11<def> = LD %vreg9, 4; mem:LD4[%2+4] CPURegs:%vreg11,%vreg9
	%A0<def> = COPY %vreg10; CPURegs:%vreg10
	%A1<def> = COPY %vreg11; CPURegs:%vreg11
	CALL <es:__muldf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg12<def> = COPY %V0; CPURegs:%vreg12
	%vreg13<def> = COPY %V1; CPURegs:%vreg13
	ST %vreg13, %vreg9, 4; mem:ST4[%2+4] CPURegs:%vreg13,%vreg9
	ST %vreg12, %vreg9, 0; mem:ST4[%2](align=8) CPURegs:%vreg12,%vreg9
	%vreg14<def> = LDHS <fi#2>, 0; mem:LD2[%xexp](align=4) CPURegs:%vreg14
	%vreg15<def> = LD <fi#0>, 0; mem:LD4[%px.addr] CPURegs:%vreg15
	ADJCALLSTACKDOWN 8, %SP<imp-def,dead>, %SP<imp-use>
	%A0<def> = COPY %vreg15; CPURegs:%vreg15
	%A1<def> = COPY %vreg14; CPURegs:%vreg14
	CALL <ga:@_Dscale>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 8, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg16<def> = COPY %V0; CPURegs:%vreg16
	%V0<def> = COPY %vreg16; CPURegs:%vreg16
	RetLR %V0<imp-use>

# End machine code for function dmul.


#####==========stderr_obj==========#####:
Pass Arguments:  -targetlibinfo -datalayout -jump-instr-table-info -notti -basictti -targetpassconfig -no-aa -tbaa -basicaa -collector-metadata -machinemoduleinfo -machine-branch-prob -jump-instr-tables -verify -verify-di -domtree -loops -loop-simplify -scalar-evolution -iv-users -loop-reduce -gc-lowering -unreachableblockelim -consthoist -codegenprepare -verify-di -stack-protector -verify -domtree -loops -branch-prob -expand-isel-pseudos -tailduplication -opt-phis -machinedomtree -slotindexes -stack-coloring -localstackalloc -dead-mi-elimination -machinedomtree -machine-loops -machinelicm -machine-cse -machine-sink -peephole-opts -machinedomtree -machine-loops -hwloops -processimpdefs -unreachable-mbb-elimination -livevars -machinedomtree -machine-loops -phi-node-elimination -twoaddressinstruction -slotindexes -liveintervals -simple-register-coalescing -machine-block-freq -livedebugvars -livestacks -virtregmap -liveregmatrix -edge-bundles -spill-code-placement -virtregrewriter -stack-slot-coloring -machinelicm -prologepilog -branch-folder -tailduplication -machine-cp -postrapseudos -machinedomtree -machine-loops -post-RA-sched -gc-analysis -machine-block-freq -block-placement2 -machinedomtree -machine-loops -packets -hwloopsfixup -stackmap-liveness
Target Library Information
Data Layout
Jump-Instruction Table Info
No target information
Target independent code generator's TTI
Target Pass Configuration
No Alias Analysis (always returns 'may' alias)
Type-Based Alias Analysis
Basic Alias Analysis (stateless AA impl)
Create Garbage Collector Module Metadata
Machine Module Information
Machine Branch Probability Analysis
  ModulePass Manager
    Jump-Instruction Tables
    FunctionPass Manager
      Module Verifier
    Debug Info Verifier
    FunctionPass Manager
      Dominator Tree Construction
      Natural Loop Information
      Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Induction Variable Users
        Loop Strength Reduction
      Lower Garbage Collection Instructions
      Remove unreachable blocks from the CFG
      Constant Hoisting
      CodeGen Prepare
      Exception handling preparation
    Debug Info Verifier
    FunctionPass Manager
      Insert stack protectors
      Module Verifier
      Machine Function Analysis
      Dominator Tree Construction
      Natural Loop Information
      Branch Probability Analysis
      DSP DAG->DAG Pattern Instruction Selection
      Expand ISel Pseudo-instructions
      Tail Duplication
      Optimize machine instruction PHIs
      MachineDominator Tree Construction
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Loop Invariant Code Motion
      Machine Common Subexpression Elimination
      Machine code sinking
      Peephole Optimizations
      DSP handle CC
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      DSP Hardware Loops
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Eliminate PHI nodes for register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Simple Register Coalescing
      Machine Block Frequency Analysis
      Debug Variable Analysis
      Live Stack Slot Analysis
      Virtual Register Map
      Live Register Matrix
      Bundle Machine CFG Edges
      Spill Code Placement Analysis
      Greedy Register Allocator
      Virtual Register Rewriter
      Stack Slot Coloring
      Machine Loop Invariant Code Motion
      Prologue/Epilogue Insertion & Frame Finalization
      Control Flow Optimizer
      Tail Duplication
      Machine Copy Propagation Pass
      Post-RA pseudo instruction expansion pass
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Post RA top-down list latency scheduler
      Analyze Machine Code For Garbage Collection
      Machine Block Frequency Analysis
      Branch Probability Basic Block Placement
      DSP Del Useless jmp
      DSP Delay Slot Filler
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      DSP Packetizer
      DSP VLIWBundlerDrive
      DSP Hardware Loop Fixup
      StackMap Liveness Analysis
      dsp assembly printer
# Machine code for function _Dtento: SSA
Frame Objects:
  fi#-1: size=4, align=8, fixed, at location [SP+8]
  fi#0: size=8, align=8, at location [SP]
  fi#1: size=8, align=8, at location [SP]
  fi#2: size=2, align=4, at location [SP]
  fi#3: size=8, align=8, at location [SP]
  fi#4: size=2, align=4, at location [SP]
  fi#5: size=4, align=4, at location [SP]
  fi#6: size=4, align=4, at location [SP]
Function Live Ins: %A0 in %vreg4, %A1 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0 %A1
	%vreg5<def> = COPY %A1; CPURegs:%vreg5
	%vreg4<def> = COPY %A0; CPURegs:%vreg4
	%vreg6<def> = LD <fi#-1>, 0; mem:LD4[FixedStack-1](align=8) CPURegs:%vreg6
	ST %vreg5, <fi#1>, 4; mem:ST4[%x.addr+4] CPURegs:%vreg5
	ST %vreg4, <fi#1>, 0; mem:ST4[%x.addr](align=8) CPURegs:%vreg4
	STH %vreg6<kill>, <fi#2>, 0; mem:ST2[%n.addr](align=4) CPURegs:%vreg6
	%vreg7<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg7
	%vreg8<def> = EQI %vreg7<kill>, 0; CPURegs:%vreg8,%vreg7
	JC %vreg8<kill>, <BB#2>; CPURegs:%vreg8
	Jmp <BB#1>
    Successors according to CFG: BB#2(12) BB#1(20)

BB#1: derived from LLVM BB %lor.lhs.false
    Predecessors according to CFG: BB#0
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg9<def> = COPY %SP; CPURegs:%vreg9
	%vreg10<def> = MovGR %ZERO, 0; CPURegs:%vreg10
	ST %vreg10, %vreg9, 12; mem:ST4[<unknown>] CPURegs:%vreg10,%vreg9
	ST %vreg10, %vreg9, 8; mem:ST4[<unknown>] CPURegs:%vreg10,%vreg9
	%vreg11<def> = LD <fi#1>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg11
	%vreg12<def> = LD <fi#1>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg12
	%A0<def> = COPY %vreg11; CPURegs:%vreg11
	%A1<def> = COPY %vreg12; CPURegs:%vreg12
	CALL <es:__nedf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg13<def> = COPY %V0; CPURegs:%vreg13
	%vreg14<def> = NEQI %vreg13, 0; CPURegs:%vreg14,%vreg13
	JC %vreg14<kill>, <BB#3>; CPURegs:%vreg14
	Jmp <BB#2>
    Successors according to CFG: BB#2(20) BB#3(12)

BB#2: derived from LLVM BB %if.then
    Predecessors according to CFG: BB#0 BB#1
	%vreg149<def> = LD <fi#1>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg149
	%vreg150<def> = LD <fi#1>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg150
	ST %vreg150<kill>, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg150
	ST %vreg149<kill>, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg149
	Jmp <BB#34>
    Successors according to CFG: BB#34

BB#3: derived from LLVM BB %if.end
    Predecessors according to CFG: BB#1
	%vreg15<def> = MovGR %ZERO, 1072693248; CPURegs:%vreg15
	ST %vreg15<kill>, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg15
	ST %vreg10, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg10
	%vreg17<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg17
	%vreg18<def> = LTI %vreg17<kill>, 0; CPURegs:%vreg18,%vreg17
	JNC %vreg18<kill>, <BB#17>; CPURegs:%vreg18
	Jmp <BB#4>
    Successors according to CFG: BB#4(12) BB#17(20)

BB#4: derived from LLVM BB %if.then7
    Predecessors according to CFG: BB#3
	%vreg77<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg77
	%vreg78<def> = MovGR %ZERO, 0; CPURegs:%vreg78
	%vreg79<def> = SUBu %vreg78, %vreg77<kill>; CPURegs:%vreg79,%vreg78,%vreg77
	ST %vreg79<kill>, <fi#6>, 0; mem:ST4[%nu] CPURegs:%vreg79
	ST %vreg78, <fi#5>, 0; mem:ST4[%i] CPURegs:%vreg78
    Successors according to CFG: BB#5

BB#5: derived from LLVM BB %for.cond
    Predecessors according to CFG: BB#4 BB#10
	%vreg81<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg81
	%vreg82<def> = EQI %vreg81<kill>, 0; CPURegs:%vreg82,%vreg81
	JC %vreg82<kill>, <BB#7>; CPURegs:%vreg82
	Jmp <BB#6>
    Successors according to CFG: BB#6(16) BB#7(16)

BB#35: 
    Predecessors according to CFG: BB#6
	%vreg154<def> = MovGR %ZERO, 1; CPURegs:%vreg154
	Jmp <BB#7>
    Successors according to CFG: BB#7

BB#6: derived from LLVM BB %land.rhs
    Predecessors according to CFG: BB#5
	%vreg83<def> = MovGR %ZERO, 8; CPURegs:%vreg83
	%vreg84<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg84
	%vreg0<def> = LTU %vreg84<kill>, %vreg83<kill>; CPURegs:%vreg0,%vreg84,%vreg83
	%vreg153<def> = MovGR %ZERO, 0; CPURegs:%vreg153
	JNC %vreg84<kill>, <BB#7>; CPURegs:%vreg84
	Jmp <BB#35>
    Successors according to CFG: BB#7 BB#35

BB#7: derived from LLVM BB %land.end
    Predecessors according to CFG: BB#5 BB#6 BB#35
	%vreg1<def> = PHI %vreg78, <BB#5>, %vreg153, <BB#6>, %vreg154, <BB#35>; CPURegs:%vreg1,%vreg78,%vreg153,%vreg154
	%vreg85<def> = EQI %vreg1, 0; CPURegs:%vreg85,%vreg1
	JC %vreg85<kill>, <BB#11>; CPURegs:%vreg85
	Jmp <BB#8>
    Successors according to CFG: BB#8(124) BB#11(4)

BB#8: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#7
	%vreg127<def> = MovGR %ZERO, 1; CPURegs:%vreg127
	%vreg128<def> = LDBZ <fi#6>, 0; mem:LD1[%nu](align=4) CPURegs:%vreg128
	%vreg129<def> = AND %vreg128<kill>, %vreg127; CPURegs:%vreg129,%vreg128,%vreg127
	%vreg130<def> = EQI %vreg129<kill>, 0; CPURegs:%vreg130,%vreg129
	JC %vreg130<kill>, <BB#10>; CPURegs:%vreg130
	Jmp <BB#9>
    Successors according to CFG: BB#9(20) BB#10(12)

BB#9: derived from LLVM BB %if.then13
    Predecessors according to CFG: BB#8
	%vreg131<def> = MovGR %ZERO, 3; CPURegs:%vreg131
	%vreg132<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg132
	%vreg133<def> = SHL %vreg132<kill>, %vreg131<kill>; CPURegs:%vreg133,%vreg132,%vreg131
	%vreg134<def> = MovIGH %ZERO, <ga:@pows>[TF=3]; CPURegs:%vreg134
	%vreg135<def,tied1> = MovIGL %vreg134<tied0>, <ga:@pows>[TF=4]; CPURegs:%vreg135,%vreg134
	%vreg136<def> = ADDu %vreg135<kill>, %vreg133<kill>; CPURegs:%vreg136,%vreg135,%vreg133
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg137<def> = COPY %SP; CPURegs:%vreg137
	%vreg138<def> = LD %vreg136, 4; mem:LD4[%arrayidx+4] CPURegs:%vreg138,%vreg136
	ST %vreg138<kill>, %vreg137, 12; mem:ST4[<unknown>] CPURegs:%vreg138,%vreg137
	%vreg139<def> = LD %vreg136, 0; mem:LD4[%arrayidx](align=8) CPURegs:%vreg139,%vreg136
	ST %vreg139<kill>, %vreg137, 8; mem:ST4[<unknown>] CPURegs:%vreg139,%vreg137
	%vreg140<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg140
	%vreg141<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg141
	%A0<def> = COPY %vreg140; CPURegs:%vreg140
	%A1<def> = COPY %vreg141; CPURegs:%vreg141
	CALL <es:__muldf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg142<def> = COPY %V0; CPURegs:%vreg142
	%vreg143<def> = COPY %V1; CPURegs:%vreg143
	ST %vreg143, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg143
	ST %vreg142, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg142
    Successors according to CFG: BB#10

BB#10: derived from LLVM BB %for.inc
    Predecessors according to CFG: BB#8 BB#9
	%vreg145<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg145
	%vreg146<def> = SRL %vreg145<kill>, %vreg127; CPURegs:%vreg146,%vreg145,%vreg127
	ST %vreg146<kill>, <fi#6>, 0; mem:ST4[%nu] CPURegs:%vreg146
	%vreg147<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg147
	%vreg148<def> = ADDiu %vreg147<kill>, 1; CPURegs:%vreg148,%vreg147
	ST %vreg148<kill>, <fi#5>, 0; mem:ST4[%i] CPURegs:%vreg148
	Jmp <BB#5>
    Successors according to CFG: BB#5

BB#11: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#7
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg86<def> = COPY %SP; CPURegs:%vreg86
	%vreg87<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg87
	ST %vreg87<kill>, %vreg86, 12; mem:ST4[<unknown>] CPURegs:%vreg87,%vreg86
	%vreg88<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg88
	ST %vreg88<kill>, %vreg86, 8; mem:ST4[<unknown>] CPURegs:%vreg88,%vreg86
	%vreg89<def> = MovGR %ZERO, 0; CPURegs:%vreg89
	%vreg90<def> = MovGR %ZERO, 1072693248; CPURegs:%vreg90
	%A0<def> = COPY %vreg89; CPURegs:%vreg89
	%A1<def> = COPY %vreg90; CPURegs:%vreg90
	CALL <es:__divdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg91<def> = COPY %V0; CPURegs:%vreg91
	%vreg92<def> = COPY %V1; CPURegs:%vreg92
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg93<def> = COPY %SP; CPURegs:%vreg93
	ST %vreg92, %vreg93, 12; mem:ST4[<unknown>] CPURegs:%vreg92,%vreg93
	ST %vreg91, %vreg93, 8; mem:ST4[<unknown>] CPURegs:%vreg91,%vreg93
	%vreg94<def> = LEA <fi#1>, 0; CPURegs:%vreg94
	%A0<def> = COPY %vreg94; CPURegs:%vreg94
	CALL <ga:@dmul>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg95<def> = COPY %V0; CPURegs:%vreg95
	STH %vreg95, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg95
	%vreg96<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg96
	%vreg97<def> = LTI %vreg96<kill>, 0; CPURegs:%vreg97,%vreg96
	JNC %vreg97<kill>, <BB#31>; CPURegs:%vreg97
	Jmp <BB#12>
    Successors according to CFG: BB#12(12) BB#31(20)

BB#12: derived from LLVM BB %land.lhs.true
    Predecessors according to CFG: BB#11
	%vreg98<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg98
	%vreg99<def> = EQI %vreg98<kill>, 0; CPURegs:%vreg99,%vreg98
	JC %vreg99<kill>, <BB#31>; CPURegs:%vreg99
	Jmp <BB#13>
    Successors according to CFG: BB#13(16) BB#31(16)

BB#13: derived from LLVM BB %if.then20
    Predecessors according to CFG: BB#12
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg100<def> = MovIGH %ZERO, <ga:@pows>[TF=3]; CPURegs:%vreg100
	%vreg101<def,tied1> = MovIGL %vreg100<tied0>, <ga:@pows>[TF=4]; CPURegs:%vreg101,%vreg100
	%vreg102<def> = COPY %SP; CPURegs:%vreg102
	%vreg103<def> = LD %vreg101, 68; mem:LD4[getelementptr inbounds ([9 x double]* @pows, i32 0, i32 8)+4] CPURegs:%vreg103,%vreg101
	ST %vreg103<kill>, %vreg102, 12; mem:ST4[<unknown>] CPURegs:%vreg103,%vreg102
	%vreg104<def> = LD %vreg101, 64; mem:LD4[getelementptr inbounds ([9 x double]* @pows, i32 0, i32 8)](align=8) CPURegs:%vreg104,%vreg101
	ST %vreg104<kill>, %vreg102, 8; mem:ST4[<unknown>] CPURegs:%vreg104,%vreg102
	%vreg105<def> = MovGR %ZERO, 0; CPURegs:%vreg105
	%vreg106<def> = MovGR %ZERO, 1072693248; CPURegs:%vreg106
	%A0<def> = COPY %vreg105; CPURegs:%vreg105
	%A1<def> = COPY %vreg106; CPURegs:%vreg106
	CALL <es:__divdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg107<def> = COPY %V0; CPURegs:%vreg107
	%vreg108<def> = COPY %V1; CPURegs:%vreg108
	ST %vreg108, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg108
	ST %vreg107, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg107
    Successors according to CFG: BB#14

BB#14: derived from LLVM BB %for.cond22
    Predecessors according to CFG: BB#13 BB#16
	%vreg109<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg109
	%vreg110<def> = EQI %vreg109<kill>, 0; CPURegs:%vreg110,%vreg109
	JC %vreg110<kill>, <BB#31>; CPURegs:%vreg110
	Jmp <BB#15>
    Successors according to CFG: BB#15(124) BB#31(4)

BB#15: derived from LLVM BB %for.body25
    Predecessors according to CFG: BB#14
	%vreg111<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg111
	%vreg112<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg112
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg113<def> = COPY %SP; CPURegs:%vreg113
	ST %vreg112<kill>, %vreg113, 12; mem:ST4[<unknown>] CPURegs:%vreg112,%vreg113
	ST %vreg111<kill>, %vreg113, 8; mem:ST4[<unknown>] CPURegs:%vreg111,%vreg113
	%vreg114<def> = LEA <fi#1>, 0; CPURegs:%vreg114
	%A0<def> = COPY %vreg114; CPURegs:%vreg114
	CALL <ga:@dmul>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg115<def> = COPY %V0; CPURegs:%vreg115
	STH %vreg115, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg115
	%vreg116<def> = LTI %vreg115, 0; CPURegs:%vreg116,%vreg115
	JNC %vreg116<kill>, <BB#31>; CPURegs:%vreg116
	Jmp <BB#16>
    Successors according to CFG: BB#31(4) BB#16(124)

BB#16: derived from LLVM BB %for.inc32
    Predecessors according to CFG: BB#15
	%vreg117<def> = LD <fi#6>, 0; mem:LD4[%nu] CPURegs:%vreg117
	%vreg118<def> = ADDiu %vreg117<kill>, -1; CPURegs:%vreg118,%vreg117
	ST %vreg118<kill>, <fi#6>, 0; mem:ST4[%nu] CPURegs:%vreg118
	Jmp <BB#14>
    Successors according to CFG: BB#14

BB#17: derived from LLVM BB %if.else
    Predecessors according to CFG: BB#3
	%vreg19<def> = MovGR %ZERO, 1; CPURegs:%vreg19
	%vreg20<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg20
	%vreg21<def> = LT %vreg20<kill>, %vreg19; CPURegs:%vreg21,%vreg20,%vreg19
	JC %vreg21<kill>, <BB#31>; CPURegs:%vreg21
	Jmp <BB#18>
    Successors according to CFG: BB#18(16) BB#31(16)

BB#18: derived from LLVM BB %if.then38
    Predecessors according to CFG: BB#17
	ST %vreg10, <fi#5>, 0; mem:ST4[%i] CPURegs:%vreg10
    Successors according to CFG: BB#19

BB#19: derived from LLVM BB %for.cond39
    Predecessors according to CFG: BB#18 BB#24
	%vreg25<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg25
	%vreg26<def> = LT %vreg25<kill>, %vreg19; CPURegs:%vreg26,%vreg25,%vreg19
	JC %vreg26<kill>, <BB#21>; CPURegs:%vreg26
	Jmp <BB#20>
    Successors according to CFG: BB#20(16) BB#21(16)

BB#20: derived from LLVM BB %land.rhs43
    Predecessors according to CFG: BB#19
	%vreg27<def> = MovGR %ZERO, 8; CPURegs:%vreg27
	%vreg28<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg28
	%vreg2<def> = LTU %vreg28<kill>, %vreg27<kill>; CPURegs:%vreg2,%vreg28,%vreg27
    Successors according to CFG: BB#21

BB#21: derived from LLVM BB %land.end46
    Predecessors according to CFG: BB#19 BB#20
	%vreg3<def> = PHI %vreg10, <BB#19>, %vreg2, <BB#20>; CPURegs:%vreg3,%vreg10,%vreg2
	%vreg29<def> = EQI %vreg3, 0; CPURegs:%vreg29,%vreg3
	JC %vreg29<kill>, <BB#25>; CPURegs:%vreg29
	Jmp <BB#22>
    Successors according to CFG: BB#22(124) BB#25(4)

BB#22: derived from LLVM BB %for.body47
    Predecessors according to CFG: BB#21
	%vreg56<def> = LDBZ <fi#2>, 0; mem:LD1[%n.addr](align=4) CPURegs:%vreg56
	%vreg57<def> = AND %vreg56<kill>, %vreg19; CPURegs:%vreg57,%vreg56,%vreg19
	%vreg58<def> = EQI %vreg57<kill>, 0; CPURegs:%vreg58,%vreg57
	JC %vreg58<kill>, <BB#24>; CPURegs:%vreg58
	Jmp <BB#23>
    Successors according to CFG: BB#23(20) BB#24(12)

BB#23: derived from LLVM BB %if.then51
    Predecessors according to CFG: BB#22
	%vreg59<def> = MovGR %ZERO, 3; CPURegs:%vreg59
	%vreg60<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg60
	%vreg61<def> = SHL %vreg60<kill>, %vreg59<kill>; CPURegs:%vreg61,%vreg60,%vreg59
	%vreg62<def> = MovIGH %ZERO, <ga:@pows>[TF=3]; CPURegs:%vreg62
	%vreg63<def,tied1> = MovIGL %vreg62<tied0>, <ga:@pows>[TF=4]; CPURegs:%vreg63,%vreg62
	%vreg64<def> = ADDu %vreg63<kill>, %vreg61<kill>; CPURegs:%vreg64,%vreg63,%vreg61
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg65<def> = COPY %SP; CPURegs:%vreg65
	%vreg66<def> = LD %vreg64, 4; mem:LD4[%arrayidx52+4] CPURegs:%vreg66,%vreg64
	ST %vreg66<kill>, %vreg65, 12; mem:ST4[<unknown>] CPURegs:%vreg66,%vreg65
	%vreg67<def> = LD %vreg64, 0; mem:LD4[%arrayidx52](align=8) CPURegs:%vreg67,%vreg64
	ST %vreg67<kill>, %vreg65, 8; mem:ST4[<unknown>] CPURegs:%vreg67,%vreg65
	%vreg68<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg68
	%vreg69<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg69
	%A0<def> = COPY %vreg68; CPURegs:%vreg68
	%A1<def> = COPY %vreg69; CPURegs:%vreg69
	CALL <es:__muldf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg70<def> = COPY %V0; CPURegs:%vreg70
	%vreg71<def> = COPY %V1; CPURegs:%vreg71
	ST %vreg71, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg71
	ST %vreg70, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg70
    Successors according to CFG: BB#24

BB#24: derived from LLVM BB %for.inc55
    Predecessors according to CFG: BB#22 BB#23
	%vreg73<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg73
	%vreg74<def> = SRL %vreg73<kill>, %vreg19; CPURegs:%vreg74,%vreg73,%vreg19
	STH %vreg74<kill>, <fi#2>, 0; mem:ST2[%n.addr](align=4) CPURegs:%vreg74
	%vreg75<def> = LD <fi#5>, 0; mem:LD4[%i] CPURegs:%vreg75
	%vreg76<def> = ADDiu %vreg75<kill>, 1; CPURegs:%vreg76,%vreg75
	ST %vreg76<kill>, <fi#5>, 0; mem:ST4[%i] CPURegs:%vreg76
	Jmp <BB#19>
    Successors according to CFG: BB#19

BB#25: derived from LLVM BB %for.end60
    Predecessors according to CFG: BB#21
	%vreg30<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg30
	%vreg31<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg31
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg32<def> = COPY %SP; CPURegs:%vreg32
	ST %vreg31<kill>, %vreg32, 12; mem:ST4[<unknown>] CPURegs:%vreg31,%vreg32
	ST %vreg30<kill>, %vreg32, 8; mem:ST4[<unknown>] CPURegs:%vreg30,%vreg32
	%vreg33<def> = LEA <fi#1>, 0; CPURegs:%vreg33
	%A0<def> = COPY %vreg33; CPURegs:%vreg33
	CALL <ga:@dmul>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg34<def> = COPY %V0; CPURegs:%vreg34
	STH %vreg34, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg34
	%vreg35<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg35
	%vreg36<def> = LTI %vreg35<kill>, 0; CPURegs:%vreg36,%vreg35
	JNC %vreg36<kill>, <BB#31>; CPURegs:%vreg36
	Jmp <BB#26>
    Successors according to CFG: BB#26(12) BB#31(20)

BB#26: derived from LLVM BB %land.lhs.true65
    Predecessors according to CFG: BB#25
	%vreg38<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg38
	%vreg39<def> = LT %vreg38<kill>, %vreg19; CPURegs:%vreg39,%vreg38,%vreg19
	JC %vreg39<kill>, <BB#31>; CPURegs:%vreg39
	Jmp <BB#27>
    Successors according to CFG: BB#27(16) BB#31(16)

BB#27: derived from LLVM BB %if.then69
    Predecessors according to CFG: BB#26
	%vreg40<def> = MovIGH %ZERO, <ga:@pows>[TF=3]; CPURegs:%vreg40
	%vreg41<def,tied1> = MovIGL %vreg40<tied0>, <ga:@pows>[TF=4]; CPURegs:%vreg41,%vreg40
	%vreg42<def> = LD %vreg41, 68; mem:LD4[getelementptr inbounds ([9 x double]* @pows, i32 0, i32 8)+4] CPURegs:%vreg42,%vreg41
	ST %vreg42<kill>, <fi#3>, 4; mem:ST4[%factor+4] CPURegs:%vreg42
	%vreg43<def> = LD %vreg41, 64; mem:LD4[getelementptr inbounds ([9 x double]* @pows, i32 0, i32 8)](align=8) CPURegs:%vreg43,%vreg41
	ST %vreg43<kill>, <fi#3>, 0; mem:ST4[%factor](align=8) CPURegs:%vreg43
    Successors according to CFG: BB#28

BB#28: derived from LLVM BB %for.cond70
    Predecessors according to CFG: BB#27 BB#30
	%vreg45<def> = LDHS <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg45
	%vreg46<def> = LT %vreg45<kill>, %vreg19; CPURegs:%vreg46,%vreg45,%vreg19
	JC %vreg46<kill>, <BB#31>; CPURegs:%vreg46
	Jmp <BB#29>
    Successors according to CFG: BB#29(124) BB#31(4)

BB#29: derived from LLVM BB %for.body74
    Predecessors according to CFG: BB#28
	%vreg47<def> = LD <fi#3>, 0; mem:LD4[%factor](align=8) CPURegs:%vreg47
	%vreg48<def> = LD <fi#3>, 4; mem:LD4[%factor+4] CPURegs:%vreg48
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg49<def> = COPY %SP; CPURegs:%vreg49
	ST %vreg48<kill>, %vreg49, 12; mem:ST4[<unknown>] CPURegs:%vreg48,%vreg49
	ST %vreg47<kill>, %vreg49, 8; mem:ST4[<unknown>] CPURegs:%vreg47,%vreg49
	%vreg50<def> = LEA <fi#1>, 0; CPURegs:%vreg50
	%A0<def> = COPY %vreg50; CPURegs:%vreg50
	CALL <ga:@dmul>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg51<def> = COPY %V0; CPURegs:%vreg51
	STH %vreg51, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg51
	%vreg52<def> = LTI %vreg51, 0; CPURegs:%vreg52,%vreg51
	JNC %vreg52<kill>, <BB#31>; CPURegs:%vreg52
	Jmp <BB#30>
    Successors according to CFG: BB#31(4) BB#30(124)

BB#30: derived from LLVM BB %for.inc81
    Predecessors according to CFG: BB#29
	%vreg53<def> = LDH <fi#2>, 0; mem:LD2[%n.addr](align=4) CPURegs:%vreg53
	%vreg54<def> = ADDiu %vreg53<kill>, -1; CPURegs:%vreg54,%vreg53
	STH %vreg54<kill>, <fi#2>, 0; mem:ST2[%n.addr](align=4) CPURegs:%vreg54
	Jmp <BB#28>
    Successors according to CFG: BB#28

BB#31: derived from LLVM BB %if.end86
    Predecessors according to CFG: BB#17 BB#25 BB#26 BB#28 BB#29 BB#11 BB#12 BB#14 BB#15
	%vreg119<def> = MovGR %ZERO, 0; CPURegs:%vreg119
	%vreg120<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg120
	%vreg121<def> = LT %vreg120<kill>, %vreg119<kill>; CPURegs:%vreg121,%vreg120,%vreg119
	JC %vreg121<kill>, <BB#33>; CPURegs:%vreg121
	Jmp <BB#32>
    Successors according to CFG: BB#32(16) BB#33(16)

BB#32: derived from LLVM BB %if.then90
    Predecessors according to CFG: BB#31
	%vreg122<def> = MovIGH %ZERO, <ga:@errno>[TF=3]; CPURegs:%vreg122
	%vreg123<def,tied1> = MovIGL %vreg122<tied0>, <ga:@errno>[TF=4]; CPURegs:%vreg123,%vreg122
	%vreg124<def> = MovGR %ZERO, 34; CPURegs:%vreg124
	ST %vreg124<kill>, %vreg123<kill>, 0; mem:ST4[@errno] CPURegs:%vreg124,%vreg123
    Successors according to CFG: BB#33

BB#33: derived from LLVM BB %if.end91
    Predecessors according to CFG: BB#31 BB#32
	%vreg125<def> = LD <fi#1>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg125
	%vreg126<def> = LD <fi#1>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg126
	ST %vreg126<kill>, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg126
	ST %vreg125<kill>, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg125
    Successors according to CFG: BB#34

BB#34: derived from LLVM BB %return
    Predecessors according to CFG: BB#33 BB#2
	%vreg151<def> = LD <fi#0>, 0; mem:LD4[%retval](align=8) CPURegs:%vreg151
	%vreg152<def> = LD <fi#0>, 4; mem:LD4[%retval+4] CPURegs:%vreg152
	%V0<def> = COPY %vreg151; CPURegs:%vreg151
	%V1<def> = COPY %vreg152; CPURegs:%vreg152
	RetLR %V0<imp-use>, %V1<imp-use>

# End machine code for function _Dtento.

# Machine code for function dmul: SSA
Frame Objects:
  fi#-2: size=4, align=4, fixed, at location [SP+12]
  fi#-1: size=4, align=8, fixed, at location [SP+8]
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=8, align=8, at location [SP]
  fi#2: size=2, align=4, at location [SP]
Function Live Ins: %A0 in %vreg0

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%vreg0<def> = COPY %A0; CPURegs:%vreg0
	%vreg1<def> = LD <fi#-1>, 0; mem:LD4[FixedStack-1](align=8) CPURegs:%vreg1
	%vreg2<def> = LD <fi#-2>, 0; mem:LD4[FixedStack-2] CPURegs:%vreg2
	ST %vreg0, <fi#0>, 0; mem:ST4[%px.addr] CPURegs:%vreg0
	ST %vreg2<kill>, <fi#1>, 4; mem:ST4[%y.addr+4] CPURegs:%vreg2
	ST %vreg1<kill>, <fi#1>, 0; mem:ST4[%y.addr](align=8) CPURegs:%vreg1
	%vreg3<def> = LD <fi#0>, 0; mem:LD4[%px.addr] CPURegs:%vreg3
	ADJCALLSTACKDOWN 8, %SP<imp-def,dead>, %SP<imp-use>
	%vreg4<def> = LEA <fi#2>, 0; CPURegs:%vreg4
	%A0<def> = COPY %vreg4; CPURegs:%vreg4
	%A1<def> = COPY %vreg3; CPURegs:%vreg3
	CALL <ga:@_Dunscale>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 8, 0, %SP<imp-def,dead>, %SP<imp-use>
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg6<def> = COPY %SP; CPURegs:%vreg6
	%vreg7<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg7
	ST %vreg7<kill>, %vreg6, 12; mem:ST4[<unknown>] CPURegs:%vreg7,%vreg6
	%vreg8<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg8
	ST %vreg8<kill>, %vreg6, 8; mem:ST4[<unknown>] CPURegs:%vreg8,%vreg6
	%vreg9<def> = LD <fi#0>, 0; mem:LD4[%px.addr] CPURegs:%vreg9
	%vreg10<def> = LD %vreg9, 0; mem:LD4[%2](align=8) CPURegs:%vreg10,%vreg9
	%vreg11<def> = LD %vreg9, 4; mem:LD4[%2+4] CPURegs:%vreg11,%vreg9
	%A0<def> = COPY %vreg10; CPURegs:%vreg10
	%A1<def> = COPY %vreg11; CPURegs:%vreg11
	CALL <es:__muldf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg12<def> = COPY %V0; CPURegs:%vreg12
	%vreg13<def> = COPY %V1; CPURegs:%vreg13
	ST %vreg13, %vreg9, 4; mem:ST4[%2+4] CPURegs:%vreg13,%vreg9
	ST %vreg12, %vreg9, 0; mem:ST4[%2](align=8) CPURegs:%vreg12,%vreg9
	%vreg14<def> = LDHS <fi#2>, 0; mem:LD2[%xexp](align=4) CPURegs:%vreg14
	%vreg15<def> = LD <fi#0>, 0; mem:LD4[%px.addr] CPURegs:%vreg15
	ADJCALLSTACKDOWN 8, %SP<imp-def,dead>, %SP<imp-use>
	%A0<def> = COPY %vreg15; CPURegs:%vreg15
	%A1<def> = COPY %vreg14; CPURegs:%vreg14
	CALL <ga:@_Dscale>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 8, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg16<def> = COPY %V0; CPURegs:%vreg16
	%V0<def> = COPY %vreg16; CPURegs:%vreg16
	RetLR %V0<imp-use>

# End machine code for function dmul.

