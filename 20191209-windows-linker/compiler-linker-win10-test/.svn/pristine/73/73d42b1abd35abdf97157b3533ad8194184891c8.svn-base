
#####==========stderr_mid==========#####:
In file included from ./c_standard_lib-master/MATH/ATAN2.c:2:
In file included from ./c_standard_lib-master/_HEADERS\xmath.h:2:
In file included from ./c_standard_lib-master/_HEADERS\errno.h:5:
./c_standard_lib-master/_HEADERS\yvals.h:35:5: warning: declaration of built-in function 'setjmp' requires inclusion of the header <setjmp.h> [-Wbuiltin-requires-header]
int setjmp(int *);
    ^
'' is not a recognized processor for this target (ignoring processor)
1 warning generated.

#####==========stderr_asm==========#####:
Pass Arguments:  -targetlibinfo -datalayout -jump-instr-table-info -notti -basictti -targetpassconfig -no-aa -tbaa -basicaa -collector-metadata -machinemoduleinfo -machine-branch-prob -jump-instr-tables -verify -verify-di -domtree -loops -loop-simplify -scalar-evolution -iv-users -loop-reduce -gc-lowering -unreachableblockelim -consthoist -codegenprepare -verify-di -stack-protector -verify -domtree -loops -branch-prob -expand-isel-pseudos -tailduplication -opt-phis -machinedomtree -slotindexes -stack-coloring -localstackalloc -dead-mi-elimination -machinedomtree -machine-loops -machinelicm -machine-cse -machine-sink -peephole-opts -machinedomtree -machine-loops -hwloops -processimpdefs -unreachable-mbb-elimination -livevars -machinedomtree -machine-loops -phi-node-elimination -twoaddressinstruction -slotindexes -liveintervals -simple-register-coalescing -machine-block-freq -livedebugvars -livestacks -virtregmap -liveregmatrix -edge-bundles -spill-code-placement -virtregrewriter -stack-slot-coloring -machinelicm -prologepilog -branch-folder -tailduplication -machine-cp -postrapseudos -machinedomtree -machine-loops -post-RA-sched -gc-analysis -machine-block-freq -block-placement2 -machinedomtree -machine-loops -packets -hwloopsfixup -stackmap-liveness
Target Library Information
Data Layout
Jump-Instruction Table Info
No target information
Target independent code generator's TTI
Target Pass Configuration
No Alias Analysis (always returns 'may' alias)
Type-Based Alias Analysis
Basic Alias Analysis (stateless AA impl)
Create Garbage Collector Module Metadata
Machine Module Information
Machine Branch Probability Analysis
  ModulePass Manager
    Jump-Instruction Tables
    FunctionPass Manager
      Module Verifier
    Debug Info Verifier
    FunctionPass Manager
      Dominator Tree Construction
      Natural Loop Information
      Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Induction Variable Users
        Loop Strength Reduction
      Lower Garbage Collection Instructions
      Remove unreachable blocks from the CFG
      Constant Hoisting
      CodeGen Prepare
      Exception handling preparation
    Debug Info Verifier
    FunctionPass Manager
      Insert stack protectors
      Module Verifier
      Machine Function Analysis
      Dominator Tree Construction
      Natural Loop Information
      Branch Probability Analysis
      DSP DAG->DAG Pattern Instruction Selection
      Expand ISel Pseudo-instructions
      Tail Duplication
      Optimize machine instruction PHIs
      MachineDominator Tree Construction
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Loop Invariant Code Motion
      Machine Common Subexpression Elimination
      Machine code sinking
      Peephole Optimizations
      DSP handle CC
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      DSP Hardware Loops
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Eliminate PHI nodes for register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Simple Register Coalescing
      Machine Block Frequency Analysis
      Debug Variable Analysis
      Live Stack Slot Analysis
      Virtual Register Map
      Live Register Matrix
      Bundle Machine CFG Edges
      Spill Code Placement Analysis
      Greedy Register Allocator
      Virtual Register Rewriter
      Stack Slot Coloring
      Machine Loop Invariant Code Motion
      Prologue/Epilogue Insertion & Frame Finalization
      Control Flow Optimizer
      Tail Duplication
      Machine Copy Propagation Pass
      Post-RA pseudo instruction expansion pass
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Post RA top-down list latency scheduler
      Analyze Machine Code For Garbage Collection
      Machine Block Frequency Analysis
      Branch Probability Basic Block Placement
      DSP Del Useless jmp
      DSP Delay Slot Filler
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      DSP Packetizer
      DSP VLIWBundlerDrive
      DSP Hardware Loop Fixup
      StackMap Liveness Analysis
      dsp assembly printer
# Machine code for function atan2: SSA
Frame Objects:
  fi#-2: size=4, align=4, fixed, at location [SP+12]
  fi#-1: size=4, align=8, fixed, at location [SP+8]
  fi#0: size=8, align=8, at location [SP]
  fi#1: size=8, align=8, at location [SP]
  fi#2: size=8, align=8, at location [SP]
  fi#3: size=8, align=8, at location [SP]
  fi#4: size=2, align=4, at location [SP]
  fi#5: size=2, align=4, at location [SP]
  fi#6: size=2, align=4, at location [SP]
Function Live Ins: %A0 in %vreg6, %A1 in %vreg7

BB#0: derived from LLVM BB %entry
    Live Ins: %A0 %A1
	%vreg7<def> = COPY %A1; CPURegs:%vreg7
	%vreg6<def> = COPY %A0; CPURegs:%vreg6
	%vreg8<def> = LD <fi#-1>, 0; mem:LD4[FixedStack-1](align=8) CPURegs:%vreg8
	%vreg9<def> = LD <fi#-2>, 0; mem:LD4[FixedStack-2] CPURegs:%vreg9
	ST %vreg7, <fi#1>, 4; mem:ST4[%y.addr+4] CPURegs:%vreg7
	ST %vreg6, <fi#1>, 0; mem:ST4[%y.addr](align=8) CPURegs:%vreg6
	ST %vreg9<kill>, <fi#2>, 4; mem:ST4[%x.addr+4] CPURegs:%vreg9
	ST %vreg8<kill>, <fi#2>, 0; mem:ST4[%x.addr](align=8) CPURegs:%vreg8
	ADJCALLSTACKDOWN 8, %SP<imp-def,dead>, %SP<imp-use>
	%vreg10<def> = LEA <fi#2>, 0; CPURegs:%vreg10
	%A0<def> = COPY %vreg10; CPURegs:%vreg10
	CALL <ga:@_Dtest>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 8, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg11<def> = COPY %V0; CPURegs:%vreg11
	STH %vreg11, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg11
	ADJCALLSTACKDOWN 8, %SP<imp-def,dead>, %SP<imp-use>
	%vreg12<def> = LEA <fi#1>, 0; CPURegs:%vreg12
	%A0<def> = COPY %vreg12; CPURegs:%vreg12
	CALL <ga:@_Dtest>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 8, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg13<def> = COPY %V0; CPURegs:%vreg13
	STH %vreg13, <fi#5>, 0; mem:ST2[%erry](align=4) CPURegs:%vreg13
	%vreg14<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg14
	%vreg15<def> = LTI %vreg14<kill>, 1; CPURegs:%vreg15,%vreg14
	JNC %vreg15<kill>, <BB#12>; CPURegs:%vreg15
	Jmp <BB#1>
    Successors according to CFG: BB#1(16) BB#12(16)

BB#1: derived from LLVM BB %land.lhs.true
    Predecessors according to CFG: BB#0
	%vreg16<def> = LDHS <fi#5>, 0; mem:LD2[%erry](align=4) CPURegs:%vreg16
	%vreg17<def> = LTI %vreg16<kill>, 1; CPURegs:%vreg17,%vreg16
	JNC %vreg17<kill>, <BB#12>; CPURegs:%vreg17
	Jmp <BB#2>
    Successors according to CFG: BB#2(16) BB#12(16)

BB#2: derived from LLVM BB %if.then
    Predecessors according to CFG: BB#1
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg51<def> = COPY %SP; CPURegs:%vreg51
	%vreg52<def> = MovGR %ZERO, 0; CPURegs:%vreg52
	ST %vreg52, %vreg51, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg51
	ST %vreg52, %vreg51, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg51
	%vreg53<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg53
	%vreg54<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg54
	%A0<def> = COPY %vreg53; CPURegs:%vreg53
	%A1<def> = COPY %vreg54; CPURegs:%vreg54
	CALL <es:__gedf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg55<def> = COPY %V0; CPURegs:%vreg55
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg56<def> = COPY %SP; CPURegs:%vreg56
	ST %vreg52, %vreg56, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg56
	ST %vreg52, %vreg56, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg56
	%vreg57<def> = MovGR %ZERO, -1; CPURegs:%vreg57
	%vreg58<def> = GT %vreg55, %vreg57; CPURegs:%vreg58,%vreg55,%vreg57
	%A0<def> = COPY %vreg53; CPURegs:%vreg53
	%A1<def> = COPY %vreg54; CPURegs:%vreg54
	CALL <es:__unorddf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg59<def> = COPY %V0; CPURegs:%vreg59
	%vreg60<def> = NEQ %vreg59, %vreg52; CPURegs:%vreg60,%vreg59,%vreg52
	%vreg61<def> = ORu %vreg60<kill>, %vreg58<kill>; CPURegs:%vreg61,%vreg60,%vreg58
	JC %vreg61<kill>, <BB#4>; CPURegs:%vreg61
	Jmp <BB#3>
    Successors according to CFG: BB#3(16) BB#4(16)

BB#3: derived from LLVM BB %if.then8
    Predecessors according to CFG: BB#2
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg63<def> = COPY %SP; CPURegs:%vreg63
	%vreg64<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg64
	ST %vreg64<kill>, %vreg63, 12; mem:ST4[<unknown>] CPURegs:%vreg64,%vreg63
	%vreg65<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg65
	ST %vreg65<kill>, %vreg63, 8; mem:ST4[<unknown>] CPURegs:%vreg65,%vreg63
	%vreg66<def> = MovGR %ZERO, 0; CPURegs:%vreg66
	%vreg67<def> = MovGR %ZERO, -2147483648; CPURegs:%vreg67
	%A0<def> = COPY %vreg66; CPURegs:%vreg66
	%A1<def> = COPY %vreg67; CPURegs:%vreg67
	CALL <es:__subdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg68<def> = COPY %V0; CPURegs:%vreg68
	%vreg69<def> = COPY %V1; CPURegs:%vreg69
	ST %vreg69, <fi#1>, 4; mem:ST4[%y.addr+4] CPURegs:%vreg69
	ST %vreg68, <fi#1>, 0; mem:ST4[%y.addr](align=8) CPURegs:%vreg68
	%vreg70<def> = MovGR %ZERO, 8; CPURegs:%vreg70
	STH %vreg70<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg70
	Jmp <BB#5>
    Successors according to CFG: BB#5

BB#4: derived from LLVM BB %if.else
    Predecessors according to CFG: BB#2
	STH %vreg52, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg52
    Successors according to CFG: BB#5

BB#5: derived from LLVM BB %if.end
    Predecessors according to CFG: BB#4 BB#3
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg71<def> = COPY %SP; CPURegs:%vreg71
	ST %vreg52, %vreg71, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg71
	ST %vreg52, %vreg71, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg71
	%vreg73<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg73
	%vreg74<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg74
	%A0<def> = COPY %vreg73; CPURegs:%vreg73
	%A1<def> = COPY %vreg74; CPURegs:%vreg74
	CALL <es:__gedf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg75<def> = COPY %V0; CPURegs:%vreg75
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg76<def> = COPY %SP; CPURegs:%vreg76
	ST %vreg52, %vreg76, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg76
	ST %vreg52, %vreg76, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg76
	%vreg78<def> = GT %vreg75, %vreg57; CPURegs:%vreg78,%vreg75,%vreg57
	%A0<def> = COPY %vreg73; CPURegs:%vreg73
	%A1<def> = COPY %vreg74; CPURegs:%vreg74
	CALL <es:__unorddf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg79<def> = COPY %V0; CPURegs:%vreg79
	%vreg80<def> = NEQ %vreg79, %vreg52; CPURegs:%vreg80,%vreg79,%vreg52
	%vreg81<def> = ORu %vreg80<kill>, %vreg78<kill>; CPURegs:%vreg81,%vreg80,%vreg78
	JC %vreg81<kill>, <BB#7>; CPURegs:%vreg81
	Jmp <BB#6>
    Successors according to CFG: BB#6(16) BB#7(16)

BB#6: derived from LLVM BB %if.then11
    Predecessors according to CFG: BB#5
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg82<def> = COPY %SP; CPURegs:%vreg82
	%vreg83<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg83
	ST %vreg83<kill>, %vreg82, 12; mem:ST4[<unknown>] CPURegs:%vreg83,%vreg82
	%vreg84<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg84
	ST %vreg84<kill>, %vreg82, 8; mem:ST4[<unknown>] CPURegs:%vreg84,%vreg82
	%vreg85<def> = MovGR %ZERO, 0; CPURegs:%vreg85
	%vreg86<def> = MovGR %ZERO, -2147483648; CPURegs:%vreg86
	%A0<def> = COPY %vreg85; CPURegs:%vreg85
	%A1<def> = COPY %vreg86; CPURegs:%vreg86
	CALL <es:__subdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg87<def> = COPY %V0; CPURegs:%vreg87
	%vreg88<def> = COPY %V1; CPURegs:%vreg88
	ST %vreg88, <fi#2>, 4; mem:ST4[%x.addr+4] CPURegs:%vreg88
	ST %vreg87, <fi#2>, 0; mem:ST4[%x.addr](align=8) CPURegs:%vreg87
	%vreg89<def> = MovGR %ZERO, 6; CPURegs:%vreg89
	%vreg90<def> = LDH <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg90
	%vreg91<def> = XORu %vreg90<kill>, %vreg89<kill>; CPURegs:%vreg91,%vreg90,%vreg89
	STH %vreg91<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg91
    Successors according to CFG: BB#7

BB#7: derived from LLVM BB %if.end15
    Predecessors according to CFG: BB#5 BB#6
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg92<def> = COPY %SP; CPURegs:%vreg92
	%vreg93<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg93
	ST %vreg93, %vreg92, 12; mem:ST4[<unknown>] CPURegs:%vreg93,%vreg92
	%vreg94<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg94
	ST %vreg94, %vreg92, 8; mem:ST4[<unknown>] CPURegs:%vreg94,%vreg92
	%vreg95<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg95
	%vreg96<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg96
	%A0<def> = COPY %vreg95; CPURegs:%vreg95
	%A1<def> = COPY %vreg96; CPURegs:%vreg96
	CALL <es:__gedf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg97<def> = COPY %V0; CPURegs:%vreg97
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg98<def> = COPY %SP; CPURegs:%vreg98
	ST %vreg93, %vreg98, 12; mem:ST4[<unknown>] CPURegs:%vreg93,%vreg98
	ST %vreg94, %vreg98, 8; mem:ST4[<unknown>] CPURegs:%vreg94,%vreg98
	%vreg100<def> = GT %vreg97, %vreg57; CPURegs:%vreg100,%vreg97,%vreg57
	%A0<def> = COPY %vreg95; CPURegs:%vreg95
	%A1<def> = COPY %vreg96; CPURegs:%vreg96
	CALL <es:__unorddf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg101<def> = COPY %V0; CPURegs:%vreg101
	%vreg103<def> = NEQ %vreg101, %vreg52; CPURegs:%vreg103,%vreg101,%vreg52
	%vreg104<def> = ORu %vreg103<kill>, %vreg100<kill>; CPURegs:%vreg104,%vreg103,%vreg100
	JC %vreg104<kill>, <BB#9>; CPURegs:%vreg104
	Jmp <BB#8>
    Successors according to CFG: BB#8(16) BB#9(16)

BB#8: derived from LLVM BB %if.then18
    Predecessors according to CFG: BB#7
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg124<def> = COPY %SP; CPURegs:%vreg124
	%vreg125<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg125
	ST %vreg125<kill>, %vreg124, 12; mem:ST4[<unknown>] CPURegs:%vreg125,%vreg124
	%vreg126<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg126
	ST %vreg126<kill>, %vreg124, 8; mem:ST4[<unknown>] CPURegs:%vreg126,%vreg124
	%vreg127<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg127
	%vreg128<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg128
	%A0<def> = COPY %vreg127; CPURegs:%vreg127
	%A1<def> = COPY %vreg128; CPURegs:%vreg128
	CALL <es:__divdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg129<def> = COPY %V0; CPURegs:%vreg129
	%vreg130<def> = COPY %V1; CPURegs:%vreg130
	ST %vreg130, <fi#3>, 4; mem:ST4[%z+4] CPURegs:%vreg130
	ST %vreg129, <fi#3>, 0; mem:ST4[%z](align=8) CPURegs:%vreg129
	%vreg131<def> = MovGR %ZERO, 2; CPURegs:%vreg131
	%vreg132<def> = LDH <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg132
	%vreg133<def> = XORu %vreg132<kill>, %vreg131<kill>; CPURegs:%vreg133,%vreg132,%vreg131
	STH %vreg133<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg133
	Jmp <BB#28>
    Successors according to CFG: BB#28

BB#9: derived from LLVM BB %if.else22
    Predecessors according to CFG: BB#7
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg105<def> = COPY %SP; CPURegs:%vreg105
	ST %vreg52, %vreg105, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg105
	ST %vreg52, %vreg105, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg105
	%vreg107<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg107
	%vreg108<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg108
	%A0<def> = COPY %vreg107; CPURegs:%vreg107
	%A1<def> = COPY %vreg108; CPURegs:%vreg108
	CALL <es:__ledf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg109<def> = COPY %V0; CPURegs:%vreg109
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg110<def> = COPY %SP; CPURegs:%vreg110
	ST %vreg52, %vreg110, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg110
	ST %vreg52, %vreg110, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg110
	%vreg111<def> = MovGR %ZERO, 1; CPURegs:%vreg111
	%vreg112<def> = LT %vreg109, %vreg111<kill>; CPURegs:%vreg112,%vreg109,%vreg111
	%A0<def> = COPY %vreg107; CPURegs:%vreg107
	%A1<def> = COPY %vreg108; CPURegs:%vreg108
	CALL <es:__unorddf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg113<def> = COPY %V0; CPURegs:%vreg113
	%vreg114<def> = NEQ %vreg113, %vreg52; CPURegs:%vreg114,%vreg113,%vreg52
	%vreg115<def> = ORu %vreg114<kill>, %vreg112<kill>; CPURegs:%vreg115,%vreg114,%vreg112
	JC %vreg115<kill>, <BB#11>; CPURegs:%vreg115
	Jmp <BB#10>
    Successors according to CFG: BB#10(16) BB#11(16)

BB#10: derived from LLVM BB %if.then25
    Predecessors according to CFG: BB#9
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg117<def> = COPY %SP; CPURegs:%vreg117
	%vreg118<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg118
	ST %vreg118<kill>, %vreg117, 12; mem:ST4[<unknown>] CPURegs:%vreg118,%vreg117
	%vreg119<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg119
	ST %vreg119<kill>, %vreg117, 8; mem:ST4[<unknown>] CPURegs:%vreg119,%vreg117
	%vreg120<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg120
	%vreg121<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg121
	%A0<def> = COPY %vreg120; CPURegs:%vreg120
	%A1<def> = COPY %vreg121; CPURegs:%vreg121
	CALL <es:__divdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg122<def> = COPY %V0; CPURegs:%vreg122
	%vreg123<def> = COPY %V1; CPURegs:%vreg123
	ST %vreg123, <fi#3>, 4; mem:ST4[%z+4] CPURegs:%vreg123
	ST %vreg122, <fi#3>, 0; mem:ST4[%z](align=8) CPURegs:%vreg122
	Jmp <BB#28>
    Successors according to CFG: BB#28

BB#11: derived from LLVM BB %if.else27
    Predecessors according to CFG: BB#9
	ST %vreg52, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg52
	ST %vreg52, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg52
	Jmp <BB#29>
    Successors according to CFG: BB#29

BB#12: derived from LLVM BB %if.else30
    Predecessors according to CFG: BB#0 BB#1
	%vreg18<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg18
	%vreg19<def> = EQI %vreg18<kill>, 2; CPURegs:%vreg19,%vreg18
	JC %vreg19<kill>, <BB#14>; CPURegs:%vreg19
	Jmp <BB#13>
    Successors according to CFG: BB#14(16) BB#13(16)

BB#13: derived from LLVM BB %lor.lhs.false
    Predecessors according to CFG: BB#12
	%vreg20<def> = LDHS <fi#5>, 0; mem:LD2[%erry](align=4) CPURegs:%vreg20
	%vreg21<def> = NEQI %vreg20<kill>, 2; CPURegs:%vreg21,%vreg20
	JC %vreg21<kill>, <BB#18>; CPURegs:%vreg21
	Jmp <BB#14>
    Successors according to CFG: BB#14(16) BB#18(16)

BB#14: derived from LLVM BB %if.then37
    Predecessors according to CFG: BB#12 BB#13
	%vreg46<def> = MovIGH %ZERO, <ga:@errno>[TF=3]; CPURegs:%vreg46
	%vreg47<def,tied1> = MovIGL %vreg46<tied0>, <ga:@errno>[TF=4]; CPURegs:%vreg47,%vreg46
	%vreg48<def> = MovGR %ZERO, 33; CPURegs:%vreg48
	ST %vreg48<kill>, %vreg47<kill>, 0; mem:ST4[@errno] CPURegs:%vreg48,%vreg47
	%vreg49<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg49
	%vreg50<def> = NEQI %vreg49<kill>, 2; CPURegs:%vreg50,%vreg49
	JC %vreg50<kill>, <BB#16>; CPURegs:%vreg50
	Jmp <BB#15>
    Successors according to CFG: BB#15(16) BB#16(16)

BB#15: derived from LLVM BB %cond.true
    Predecessors according to CFG: BB#14
	%vreg1<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg1
	%vreg0<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg0
	Jmp <BB#17>
    Successors according to CFG: BB#17

BB#16: derived from LLVM BB %cond.false
    Predecessors according to CFG: BB#14
	%vreg3<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg3
	%vreg2<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg2
    Successors according to CFG: BB#17

BB#17: derived from LLVM BB %cond.end
    Predecessors according to CFG: BB#16 BB#15
	%vreg4<def> = PHI %vreg2, <BB#16>, %vreg0, <BB#15>; CPURegs:%vreg4,%vreg2,%vreg0
	%vreg5<def> = PHI %vreg3, <BB#16>, %vreg1, <BB#15>; CPURegs:%vreg5,%vreg3,%vreg1
	ST %vreg4, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg4
	ST %vreg5, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg5
	Jmp <BB#29>
    Successors according to CFG: BB#29

BB#18: derived from LLVM BB %if.else41
    Predecessors according to CFG: BB#13
	%vreg22<def> = LDHS <fi#5>, 0; mem:LD2[%erry](align=4) CPURegs:%vreg22
	%vreg23<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg23
	%vreg24<def> = NEQ %vreg23<kill>, %vreg22<kill>; CPURegs:%vreg24,%vreg23,%vreg22
	JC %vreg24<kill>, <BB#20>; CPURegs:%vreg24
	Jmp <BB#19>
    Successors according to CFG: BB#19(16) BB#20(16)

BB#19: derived from LLVM BB %if.then46
    Predecessors according to CFG: BB#18
	%vreg26<def> = MovGR %ZERO, 1072693248; CPURegs:%vreg26
	ST %vreg26<kill>, <fi#3>, 4; mem:ST4[%z+4] CPURegs:%vreg26
	%vreg27<def> = MovGR %ZERO, 0; CPURegs:%vreg27
	ST %vreg27<kill>, <fi#3>, 0; mem:ST4[%z](align=8) CPURegs:%vreg27
	Jmp <BB#21>
    Successors according to CFG: BB#21

BB#20: derived from LLVM BB %if.else47
    Predecessors according to CFG: BB#18
	%vreg25<def> = MovGR %ZERO, 0; CPURegs:%vreg25
	ST %vreg25, <fi#3>, 4; mem:ST4[%z+4] CPURegs:%vreg25
	ST %vreg25, <fi#3>, 0; mem:ST4[%z](align=8) CPURegs:%vreg25
    Successors according to CFG: BB#21

BB#21: derived from LLVM BB %if.end48
    Predecessors according to CFG: BB#20 BB#19
	%vreg28<def> = MovGR %ZERO, 128; CPURegs:%vreg28
	%vreg29<def> = LDBZ <fi#1>, 7; mem:LD1[%arrayidx+1] CPURegs:%vreg29
	%vreg30<def> = AND %vreg29<kill>, %vreg28; CPURegs:%vreg30,%vreg29,%vreg28
	%vreg31<def> = EQI %vreg30<kill>, 0; CPURegs:%vreg31,%vreg30
	JC %vreg31<kill>, <BB#23>; CPURegs:%vreg31
	Jmp <BB#22>
    Successors according to CFG: BB#22(20) BB#23(12)

BB#22: derived from LLVM BB %if.then50
    Predecessors according to CFG: BB#21
	%vreg33<def> = MovGR %ZERO, 8; CPURegs:%vreg33
	STH %vreg33<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg33
	Jmp <BB#24>
    Successors according to CFG: BB#24

BB#23: derived from LLVM BB %if.else51
    Predecessors according to CFG: BB#21
	%vreg32<def> = MovGR %ZERO, 0; CPURegs:%vreg32
	STH %vreg32<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg32
    Successors according to CFG: BB#24

BB#24: derived from LLVM BB %if.end52
    Predecessors according to CFG: BB#23 BB#22
	%vreg35<def> = LDBZ <fi#2>, 7; mem:LD1[%arrayidx53+1] CPURegs:%vreg35
	%vreg36<def> = AND %vreg35<kill>, %vreg28; CPURegs:%vreg36,%vreg35,%vreg28
	%vreg37<def> = EQI %vreg36<kill>, 0; CPURegs:%vreg37,%vreg36
	JC %vreg37<kill>, <BB#26>; CPURegs:%vreg37
	Jmp <BB#25>
    Successors according to CFG: BB#25(20) BB#26(12)

BB#25: derived from LLVM BB %if.then57
    Predecessors according to CFG: BB#24
	%vreg38<def> = MovGR %ZERO, 6; CPURegs:%vreg38
	%vreg39<def> = LDH <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg39
	%vreg40<def> = XORu %vreg39<kill>, %vreg38<kill>; CPURegs:%vreg40,%vreg39,%vreg38
	STH %vreg40<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg40
    Successors according to CFG: BB#26

BB#26: derived from LLVM BB %if.end61
    Predecessors according to CFG: BB#24 BB#25
	%vreg41<def> = LDHS <fi#5>, 0; mem:LD2[%erry](align=4) CPURegs:%vreg41
	%vreg42<def> = NEQI %vreg41<kill>, 1; CPURegs:%vreg42,%vreg41
	JC %vreg42<kill>, <BB#28>; CPURegs:%vreg42
	Jmp <BB#27>
    Successors according to CFG: BB#27(16) BB#28(16)

BB#27: derived from LLVM BB %if.then65
    Predecessors according to CFG: BB#26
	%vreg43<def> = MovGR %ZERO, 2; CPURegs:%vreg43
	%vreg44<def> = LDH <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg44
	%vreg45<def> = XORu %vreg44<kill>, %vreg43<kill>; CPURegs:%vreg45,%vreg44,%vreg43
	STH %vreg45<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg45
    Successors according to CFG: BB#28

BB#28: derived from LLVM BB %if.end71
    Predecessors according to CFG: BB#26 BB#27 BB#10 BB#8
	%vreg134<def> = LD <fi#3>, 4; mem:LD4[%z+4] CPURegs:%vreg134
	%vreg135<def> = LD <fi#3>, 0; mem:LD4[%z](align=8) CPURegs:%vreg135
	%vreg136<def> = LDHZ <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg136
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg137<def> = COPY %SP; CPURegs:%vreg137
	ST %vreg136<kill>, %vreg137, 8; mem:ST4[<unknown>] CPURegs:%vreg136,%vreg137
	%A0<def> = COPY %vreg135; CPURegs:%vreg135
	%A1<def> = COPY %vreg134; CPURegs:%vreg134
	CALL <ga:@_Atan>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg138<def> = COPY %V0; CPURegs:%vreg138
	%vreg139<def> = COPY %V1; CPURegs:%vreg139
	ST %vreg139, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg139
	ST %vreg138, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg138
    Successors according to CFG: BB#29

BB#29: derived from LLVM BB %return
    Predecessors according to CFG: BB#17 BB#11 BB#28
	%vreg140<def> = LD <fi#0>, 0; mem:LD4[%retval](align=8) CPURegs:%vreg140
	%vreg141<def> = LD <fi#0>, 4; mem:LD4[%retval+4] CPURegs:%vreg141
	%V0<def> = COPY %vreg140; CPURegs:%vreg140
	%V1<def> = COPY %vreg141; CPURegs:%vreg141
	RetLR %V0<imp-use>, %V1<imp-use>

# End machine code for function atan2.


#####==========stderr_obj==========#####:
Pass Arguments:  -targetlibinfo -datalayout -jump-instr-table-info -notti -basictti -targetpassconfig -no-aa -tbaa -basicaa -collector-metadata -machinemoduleinfo -machine-branch-prob -jump-instr-tables -verify -verify-di -domtree -loops -loop-simplify -scalar-evolution -iv-users -loop-reduce -gc-lowering -unreachableblockelim -consthoist -codegenprepare -verify-di -stack-protector -verify -domtree -loops -branch-prob -expand-isel-pseudos -tailduplication -opt-phis -machinedomtree -slotindexes -stack-coloring -localstackalloc -dead-mi-elimination -machinedomtree -machine-loops -machinelicm -machine-cse -machine-sink -peephole-opts -machinedomtree -machine-loops -hwloops -processimpdefs -unreachable-mbb-elimination -livevars -machinedomtree -machine-loops -phi-node-elimination -twoaddressinstruction -slotindexes -liveintervals -simple-register-coalescing -machine-block-freq -livedebugvars -livestacks -virtregmap -liveregmatrix -edge-bundles -spill-code-placement -virtregrewriter -stack-slot-coloring -machinelicm -prologepilog -branch-folder -tailduplication -machine-cp -postrapseudos -machinedomtree -machine-loops -post-RA-sched -gc-analysis -machine-block-freq -block-placement2 -machinedomtree -machine-loops -packets -hwloopsfixup -stackmap-liveness
Target Library Information
Data Layout
Jump-Instruction Table Info
No target information
Target independent code generator's TTI
Target Pass Configuration
No Alias Analysis (always returns 'may' alias)
Type-Based Alias Analysis
Basic Alias Analysis (stateless AA impl)
Create Garbage Collector Module Metadata
Machine Module Information
Machine Branch Probability Analysis
  ModulePass Manager
    Jump-Instruction Tables
    FunctionPass Manager
      Module Verifier
    Debug Info Verifier
    FunctionPass Manager
      Dominator Tree Construction
      Natural Loop Information
      Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Induction Variable Users
        Loop Strength Reduction
      Lower Garbage Collection Instructions
      Remove unreachable blocks from the CFG
      Constant Hoisting
      CodeGen Prepare
      Exception handling preparation
    Debug Info Verifier
    FunctionPass Manager
      Insert stack protectors
      Module Verifier
      Machine Function Analysis
      Dominator Tree Construction
      Natural Loop Information
      Branch Probability Analysis
      DSP DAG->DAG Pattern Instruction Selection
      Expand ISel Pseudo-instructions
      Tail Duplication
      Optimize machine instruction PHIs
      MachineDominator Tree Construction
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Loop Invariant Code Motion
      Machine Common Subexpression Elimination
      Machine code sinking
      Peephole Optimizations
      DSP handle CC
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      DSP Hardware Loops
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Eliminate PHI nodes for register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Simple Register Coalescing
      Machine Block Frequency Analysis
      Debug Variable Analysis
      Live Stack Slot Analysis
      Virtual Register Map
      Live Register Matrix
      Bundle Machine CFG Edges
      Spill Code Placement Analysis
      Greedy Register Allocator
      Virtual Register Rewriter
      Stack Slot Coloring
      Machine Loop Invariant Code Motion
      Prologue/Epilogue Insertion & Frame Finalization
      Control Flow Optimizer
      Tail Duplication
      Machine Copy Propagation Pass
      Post-RA pseudo instruction expansion pass
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Post RA top-down list latency scheduler
      Analyze Machine Code For Garbage Collection
      Machine Block Frequency Analysis
      Branch Probability Basic Block Placement
      DSP Del Useless jmp
      DSP Delay Slot Filler
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      DSP Packetizer
      DSP VLIWBundlerDrive
      DSP Hardware Loop Fixup
      StackMap Liveness Analysis
      dsp assembly printer
# Machine code for function atan2: SSA
Frame Objects:
  fi#-2: size=4, align=4, fixed, at location [SP+12]
  fi#-1: size=4, align=8, fixed, at location [SP+8]
  fi#0: size=8, align=8, at location [SP]
  fi#1: size=8, align=8, at location [SP]
  fi#2: size=8, align=8, at location [SP]
  fi#3: size=8, align=8, at location [SP]
  fi#4: size=2, align=4, at location [SP]
  fi#5: size=2, align=4, at location [SP]
  fi#6: size=2, align=4, at location [SP]
Function Live Ins: %A0 in %vreg6, %A1 in %vreg7

BB#0: derived from LLVM BB %entry
    Live Ins: %A0 %A1
	%vreg7<def> = COPY %A1; CPURegs:%vreg7
	%vreg6<def> = COPY %A0; CPURegs:%vreg6
	%vreg8<def> = LD <fi#-1>, 0; mem:LD4[FixedStack-1](align=8) CPURegs:%vreg8
	%vreg9<def> = LD <fi#-2>, 0; mem:LD4[FixedStack-2] CPURegs:%vreg9
	ST %vreg7, <fi#1>, 4; mem:ST4[%y.addr+4] CPURegs:%vreg7
	ST %vreg6, <fi#1>, 0; mem:ST4[%y.addr](align=8) CPURegs:%vreg6
	ST %vreg9<kill>, <fi#2>, 4; mem:ST4[%x.addr+4] CPURegs:%vreg9
	ST %vreg8<kill>, <fi#2>, 0; mem:ST4[%x.addr](align=8) CPURegs:%vreg8
	ADJCALLSTACKDOWN 8, %SP<imp-def,dead>, %SP<imp-use>
	%vreg10<def> = LEA <fi#2>, 0; CPURegs:%vreg10
	%A0<def> = COPY %vreg10; CPURegs:%vreg10
	CALL <ga:@_Dtest>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 8, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg11<def> = COPY %V0; CPURegs:%vreg11
	STH %vreg11, <fi#4>, 0; mem:ST2[%errx](align=4) CPURegs:%vreg11
	ADJCALLSTACKDOWN 8, %SP<imp-def,dead>, %SP<imp-use>
	%vreg12<def> = LEA <fi#1>, 0; CPURegs:%vreg12
	%A0<def> = COPY %vreg12; CPURegs:%vreg12
	CALL <ga:@_Dtest>, %A0, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 8, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg13<def> = COPY %V0; CPURegs:%vreg13
	STH %vreg13, <fi#5>, 0; mem:ST2[%erry](align=4) CPURegs:%vreg13
	%vreg14<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg14
	%vreg15<def> = LTI %vreg14<kill>, 1; CPURegs:%vreg15,%vreg14
	JNC %vreg15<kill>, <BB#12>; CPURegs:%vreg15
	Jmp <BB#1>
    Successors according to CFG: BB#1(16) BB#12(16)

BB#1: derived from LLVM BB %land.lhs.true
    Predecessors according to CFG: BB#0
	%vreg16<def> = LDHS <fi#5>, 0; mem:LD2[%erry](align=4) CPURegs:%vreg16
	%vreg17<def> = LTI %vreg16<kill>, 1; CPURegs:%vreg17,%vreg16
	JNC %vreg17<kill>, <BB#12>; CPURegs:%vreg17
	Jmp <BB#2>
    Successors according to CFG: BB#2(16) BB#12(16)

BB#2: derived from LLVM BB %if.then
    Predecessors according to CFG: BB#1
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg51<def> = COPY %SP; CPURegs:%vreg51
	%vreg52<def> = MovGR %ZERO, 0; CPURegs:%vreg52
	ST %vreg52, %vreg51, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg51
	ST %vreg52, %vreg51, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg51
	%vreg53<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg53
	%vreg54<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg54
	%A0<def> = COPY %vreg53; CPURegs:%vreg53
	%A1<def> = COPY %vreg54; CPURegs:%vreg54
	CALL <es:__gedf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg55<def> = COPY %V0; CPURegs:%vreg55
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg56<def> = COPY %SP; CPURegs:%vreg56
	ST %vreg52, %vreg56, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg56
	ST %vreg52, %vreg56, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg56
	%vreg57<def> = MovGR %ZERO, -1; CPURegs:%vreg57
	%vreg58<def> = GT %vreg55, %vreg57; CPURegs:%vreg58,%vreg55,%vreg57
	%A0<def> = COPY %vreg53; CPURegs:%vreg53
	%A1<def> = COPY %vreg54; CPURegs:%vreg54
	CALL <es:__unorddf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg59<def> = COPY %V0; CPURegs:%vreg59
	%vreg60<def> = NEQ %vreg59, %vreg52; CPURegs:%vreg60,%vreg59,%vreg52
	%vreg61<def> = ORu %vreg60<kill>, %vreg58<kill>; CPURegs:%vreg61,%vreg60,%vreg58
	JC %vreg61<kill>, <BB#4>; CPURegs:%vreg61
	Jmp <BB#3>
    Successors according to CFG: BB#3(16) BB#4(16)

BB#3: derived from LLVM BB %if.then8
    Predecessors according to CFG: BB#2
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg63<def> = COPY %SP; CPURegs:%vreg63
	%vreg64<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg64
	ST %vreg64<kill>, %vreg63, 12; mem:ST4[<unknown>] CPURegs:%vreg64,%vreg63
	%vreg65<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg65
	ST %vreg65<kill>, %vreg63, 8; mem:ST4[<unknown>] CPURegs:%vreg65,%vreg63
	%vreg66<def> = MovGR %ZERO, 0; CPURegs:%vreg66
	%vreg67<def> = MovGR %ZERO, -2147483648; CPURegs:%vreg67
	%A0<def> = COPY %vreg66; CPURegs:%vreg66
	%A1<def> = COPY %vreg67; CPURegs:%vreg67
	CALL <es:__subdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg68<def> = COPY %V0; CPURegs:%vreg68
	%vreg69<def> = COPY %V1; CPURegs:%vreg69
	ST %vreg69, <fi#1>, 4; mem:ST4[%y.addr+4] CPURegs:%vreg69
	ST %vreg68, <fi#1>, 0; mem:ST4[%y.addr](align=8) CPURegs:%vreg68
	%vreg70<def> = MovGR %ZERO, 8; CPURegs:%vreg70
	STH %vreg70<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg70
	Jmp <BB#5>
    Successors according to CFG: BB#5

BB#4: derived from LLVM BB %if.else
    Predecessors according to CFG: BB#2
	STH %vreg52, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg52
    Successors according to CFG: BB#5

BB#5: derived from LLVM BB %if.end
    Predecessors according to CFG: BB#4 BB#3
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg71<def> = COPY %SP; CPURegs:%vreg71
	ST %vreg52, %vreg71, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg71
	ST %vreg52, %vreg71, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg71
	%vreg73<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg73
	%vreg74<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg74
	%A0<def> = COPY %vreg73; CPURegs:%vreg73
	%A1<def> = COPY %vreg74; CPURegs:%vreg74
	CALL <es:__gedf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg75<def> = COPY %V0; CPURegs:%vreg75
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg76<def> = COPY %SP; CPURegs:%vreg76
	ST %vreg52, %vreg76, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg76
	ST %vreg52, %vreg76, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg76
	%vreg78<def> = GT %vreg75, %vreg57; CPURegs:%vreg78,%vreg75,%vreg57
	%A0<def> = COPY %vreg73; CPURegs:%vreg73
	%A1<def> = COPY %vreg74; CPURegs:%vreg74
	CALL <es:__unorddf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg79<def> = COPY %V0; CPURegs:%vreg79
	%vreg80<def> = NEQ %vreg79, %vreg52; CPURegs:%vreg80,%vreg79,%vreg52
	%vreg81<def> = ORu %vreg80<kill>, %vreg78<kill>; CPURegs:%vreg81,%vreg80,%vreg78
	JC %vreg81<kill>, <BB#7>; CPURegs:%vreg81
	Jmp <BB#6>
    Successors according to CFG: BB#6(16) BB#7(16)

BB#6: derived from LLVM BB %if.then11
    Predecessors according to CFG: BB#5
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg82<def> = COPY %SP; CPURegs:%vreg82
	%vreg83<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg83
	ST %vreg83<kill>, %vreg82, 12; mem:ST4[<unknown>] CPURegs:%vreg83,%vreg82
	%vreg84<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg84
	ST %vreg84<kill>, %vreg82, 8; mem:ST4[<unknown>] CPURegs:%vreg84,%vreg82
	%vreg85<def> = MovGR %ZERO, 0; CPURegs:%vreg85
	%vreg86<def> = MovGR %ZERO, -2147483648; CPURegs:%vreg86
	%A0<def> = COPY %vreg85; CPURegs:%vreg85
	%A1<def> = COPY %vreg86; CPURegs:%vreg86
	CALL <es:__subdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg87<def> = COPY %V0; CPURegs:%vreg87
	%vreg88<def> = COPY %V1; CPURegs:%vreg88
	ST %vreg88, <fi#2>, 4; mem:ST4[%x.addr+4] CPURegs:%vreg88
	ST %vreg87, <fi#2>, 0; mem:ST4[%x.addr](align=8) CPURegs:%vreg87
	%vreg89<def> = MovGR %ZERO, 6; CPURegs:%vreg89
	%vreg90<def> = LDH <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg90
	%vreg91<def> = XORu %vreg90<kill>, %vreg89<kill>; CPURegs:%vreg91,%vreg90,%vreg89
	STH %vreg91<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg91
    Successors according to CFG: BB#7

BB#7: derived from LLVM BB %if.end15
    Predecessors according to CFG: BB#5 BB#6
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg92<def> = COPY %SP; CPURegs:%vreg92
	%vreg93<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg93
	ST %vreg93, %vreg92, 12; mem:ST4[<unknown>] CPURegs:%vreg93,%vreg92
	%vreg94<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg94
	ST %vreg94, %vreg92, 8; mem:ST4[<unknown>] CPURegs:%vreg94,%vreg92
	%vreg95<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg95
	%vreg96<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg96
	%A0<def> = COPY %vreg95; CPURegs:%vreg95
	%A1<def> = COPY %vreg96; CPURegs:%vreg96
	CALL <es:__gedf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg97<def> = COPY %V0; CPURegs:%vreg97
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg98<def> = COPY %SP; CPURegs:%vreg98
	ST %vreg93, %vreg98, 12; mem:ST4[<unknown>] CPURegs:%vreg93,%vreg98
	ST %vreg94, %vreg98, 8; mem:ST4[<unknown>] CPURegs:%vreg94,%vreg98
	%vreg100<def> = GT %vreg97, %vreg57; CPURegs:%vreg100,%vreg97,%vreg57
	%A0<def> = COPY %vreg95; CPURegs:%vreg95
	%A1<def> = COPY %vreg96; CPURegs:%vreg96
	CALL <es:__unorddf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg101<def> = COPY %V0; CPURegs:%vreg101
	%vreg103<def> = NEQ %vreg101, %vreg52; CPURegs:%vreg103,%vreg101,%vreg52
	%vreg104<def> = ORu %vreg103<kill>, %vreg100<kill>; CPURegs:%vreg104,%vreg103,%vreg100
	JC %vreg104<kill>, <BB#9>; CPURegs:%vreg104
	Jmp <BB#8>
    Successors according to CFG: BB#8(16) BB#9(16)

BB#8: derived from LLVM BB %if.then18
    Predecessors according to CFG: BB#7
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg124<def> = COPY %SP; CPURegs:%vreg124
	%vreg125<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg125
	ST %vreg125<kill>, %vreg124, 12; mem:ST4[<unknown>] CPURegs:%vreg125,%vreg124
	%vreg126<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg126
	ST %vreg126<kill>, %vreg124, 8; mem:ST4[<unknown>] CPURegs:%vreg126,%vreg124
	%vreg127<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg127
	%vreg128<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg128
	%A0<def> = COPY %vreg127; CPURegs:%vreg127
	%A1<def> = COPY %vreg128; CPURegs:%vreg128
	CALL <es:__divdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg129<def> = COPY %V0; CPURegs:%vreg129
	%vreg130<def> = COPY %V1; CPURegs:%vreg130
	ST %vreg130, <fi#3>, 4; mem:ST4[%z+4] CPURegs:%vreg130
	ST %vreg129, <fi#3>, 0; mem:ST4[%z](align=8) CPURegs:%vreg129
	%vreg131<def> = MovGR %ZERO, 2; CPURegs:%vreg131
	%vreg132<def> = LDH <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg132
	%vreg133<def> = XORu %vreg132<kill>, %vreg131<kill>; CPURegs:%vreg133,%vreg132,%vreg131
	STH %vreg133<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg133
	Jmp <BB#28>
    Successors according to CFG: BB#28

BB#9: derived from LLVM BB %if.else22
    Predecessors according to CFG: BB#7
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg105<def> = COPY %SP; CPURegs:%vreg105
	ST %vreg52, %vreg105, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg105
	ST %vreg52, %vreg105, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg105
	%vreg107<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg107
	%vreg108<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg108
	%A0<def> = COPY %vreg107; CPURegs:%vreg107
	%A1<def> = COPY %vreg108; CPURegs:%vreg108
	CALL <es:__ledf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg109<def> = COPY %V0; CPURegs:%vreg109
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg110<def> = COPY %SP; CPURegs:%vreg110
	ST %vreg52, %vreg110, 12; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg110
	ST %vreg52, %vreg110, 8; mem:ST4[<unknown>] CPURegs:%vreg52,%vreg110
	%vreg111<def> = MovGR %ZERO, 1; CPURegs:%vreg111
	%vreg112<def> = LT %vreg109, %vreg111<kill>; CPURegs:%vreg112,%vreg109,%vreg111
	%A0<def> = COPY %vreg107; CPURegs:%vreg107
	%A1<def> = COPY %vreg108; CPURegs:%vreg108
	CALL <es:__unorddf2>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg113<def> = COPY %V0; CPURegs:%vreg113
	%vreg114<def> = NEQ %vreg113, %vreg52; CPURegs:%vreg114,%vreg113,%vreg52
	%vreg115<def> = ORu %vreg114<kill>, %vreg112<kill>; CPURegs:%vreg115,%vreg114,%vreg112
	JC %vreg115<kill>, <BB#11>; CPURegs:%vreg115
	Jmp <BB#10>
    Successors according to CFG: BB#10(16) BB#11(16)

BB#10: derived from LLVM BB %if.then25
    Predecessors according to CFG: BB#9
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg117<def> = COPY %SP; CPURegs:%vreg117
	%vreg118<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg118
	ST %vreg118<kill>, %vreg117, 12; mem:ST4[<unknown>] CPURegs:%vreg118,%vreg117
	%vreg119<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg119
	ST %vreg119<kill>, %vreg117, 8; mem:ST4[<unknown>] CPURegs:%vreg119,%vreg117
	%vreg120<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg120
	%vreg121<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg121
	%A0<def> = COPY %vreg120; CPURegs:%vreg120
	%A1<def> = COPY %vreg121; CPURegs:%vreg121
	CALL <es:__divdf3>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg122<def> = COPY %V0; CPURegs:%vreg122
	%vreg123<def> = COPY %V1; CPURegs:%vreg123
	ST %vreg123, <fi#3>, 4; mem:ST4[%z+4] CPURegs:%vreg123
	ST %vreg122, <fi#3>, 0; mem:ST4[%z](align=8) CPURegs:%vreg122
	Jmp <BB#28>
    Successors according to CFG: BB#28

BB#11: derived from LLVM BB %if.else27
    Predecessors according to CFG: BB#9
	ST %vreg52, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg52
	ST %vreg52, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg52
	Jmp <BB#29>
    Successors according to CFG: BB#29

BB#12: derived from LLVM BB %if.else30
    Predecessors according to CFG: BB#0 BB#1
	%vreg18<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg18
	%vreg19<def> = EQI %vreg18<kill>, 2; CPURegs:%vreg19,%vreg18
	JC %vreg19<kill>, <BB#14>; CPURegs:%vreg19
	Jmp <BB#13>
    Successors according to CFG: BB#14(16) BB#13(16)

BB#13: derived from LLVM BB %lor.lhs.false
    Predecessors according to CFG: BB#12
	%vreg20<def> = LDHS <fi#5>, 0; mem:LD2[%erry](align=4) CPURegs:%vreg20
	%vreg21<def> = NEQI %vreg20<kill>, 2; CPURegs:%vreg21,%vreg20
	JC %vreg21<kill>, <BB#18>; CPURegs:%vreg21
	Jmp <BB#14>
    Successors according to CFG: BB#14(16) BB#18(16)

BB#14: derived from LLVM BB %if.then37
    Predecessors according to CFG: BB#12 BB#13
	%vreg46<def> = MovIGH %ZERO, <ga:@errno>[TF=3]; CPURegs:%vreg46
	%vreg47<def,tied1> = MovIGL %vreg46<tied0>, <ga:@errno>[TF=4]; CPURegs:%vreg47,%vreg46
	%vreg48<def> = MovGR %ZERO, 33; CPURegs:%vreg48
	ST %vreg48<kill>, %vreg47<kill>, 0; mem:ST4[@errno] CPURegs:%vreg48,%vreg47
	%vreg49<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg49
	%vreg50<def> = NEQI %vreg49<kill>, 2; CPURegs:%vreg50,%vreg49
	JC %vreg50<kill>, <BB#16>; CPURegs:%vreg50
	Jmp <BB#15>
    Successors according to CFG: BB#15(16) BB#16(16)

BB#15: derived from LLVM BB %cond.true
    Predecessors according to CFG: BB#14
	%vreg1<def> = LD <fi#2>, 4; mem:LD4[%x.addr+4] CPURegs:%vreg1
	%vreg0<def> = LD <fi#2>, 0; mem:LD4[%x.addr](align=8) CPURegs:%vreg0
	Jmp <BB#17>
    Successors according to CFG: BB#17

BB#16: derived from LLVM BB %cond.false
    Predecessors according to CFG: BB#14
	%vreg3<def> = LD <fi#1>, 4; mem:LD4[%y.addr+4] CPURegs:%vreg3
	%vreg2<def> = LD <fi#1>, 0; mem:LD4[%y.addr](align=8) CPURegs:%vreg2
    Successors according to CFG: BB#17

BB#17: derived from LLVM BB %cond.end
    Predecessors according to CFG: BB#16 BB#15
	%vreg4<def> = PHI %vreg2, <BB#16>, %vreg0, <BB#15>; CPURegs:%vreg4,%vreg2,%vreg0
	%vreg5<def> = PHI %vreg3, <BB#16>, %vreg1, <BB#15>; CPURegs:%vreg5,%vreg3,%vreg1
	ST %vreg4, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg4
	ST %vreg5, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg5
	Jmp <BB#29>
    Successors according to CFG: BB#29

BB#18: derived from LLVM BB %if.else41
    Predecessors according to CFG: BB#13
	%vreg22<def> = LDHS <fi#5>, 0; mem:LD2[%erry](align=4) CPURegs:%vreg22
	%vreg23<def> = LDHS <fi#4>, 0; mem:LD2[%errx](align=4) CPURegs:%vreg23
	%vreg24<def> = NEQ %vreg23<kill>, %vreg22<kill>; CPURegs:%vreg24,%vreg23,%vreg22
	JC %vreg24<kill>, <BB#20>; CPURegs:%vreg24
	Jmp <BB#19>
    Successors according to CFG: BB#19(16) BB#20(16)

BB#19: derived from LLVM BB %if.then46
    Predecessors according to CFG: BB#18
	%vreg26<def> = MovGR %ZERO, 1072693248; CPURegs:%vreg26
	ST %vreg26<kill>, <fi#3>, 4; mem:ST4[%z+4] CPURegs:%vreg26
	%vreg27<def> = MovGR %ZERO, 0; CPURegs:%vreg27
	ST %vreg27<kill>, <fi#3>, 0; mem:ST4[%z](align=8) CPURegs:%vreg27
	Jmp <BB#21>
    Successors according to CFG: BB#21

BB#20: derived from LLVM BB %if.else47
    Predecessors according to CFG: BB#18
	%vreg25<def> = MovGR %ZERO, 0; CPURegs:%vreg25
	ST %vreg25, <fi#3>, 4; mem:ST4[%z+4] CPURegs:%vreg25
	ST %vreg25, <fi#3>, 0; mem:ST4[%z](align=8) CPURegs:%vreg25
    Successors according to CFG: BB#21

BB#21: derived from LLVM BB %if.end48
    Predecessors according to CFG: BB#20 BB#19
	%vreg28<def> = MovGR %ZERO, 128; CPURegs:%vreg28
	%vreg29<def> = LDBZ <fi#1>, 7; mem:LD1[%arrayidx+1] CPURegs:%vreg29
	%vreg30<def> = AND %vreg29<kill>, %vreg28; CPURegs:%vreg30,%vreg29,%vreg28
	%vreg31<def> = EQI %vreg30<kill>, 0; CPURegs:%vreg31,%vreg30
	JC %vreg31<kill>, <BB#23>; CPURegs:%vreg31
	Jmp <BB#22>
    Successors according to CFG: BB#22(20) BB#23(12)

BB#22: derived from LLVM BB %if.then50
    Predecessors according to CFG: BB#21
	%vreg33<def> = MovGR %ZERO, 8; CPURegs:%vreg33
	STH %vreg33<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg33
	Jmp <BB#24>
    Successors according to CFG: BB#24

BB#23: derived from LLVM BB %if.else51
    Predecessors according to CFG: BB#21
	%vreg32<def> = MovGR %ZERO, 0; CPURegs:%vreg32
	STH %vreg32<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg32
    Successors according to CFG: BB#24

BB#24: derived from LLVM BB %if.end52
    Predecessors according to CFG: BB#23 BB#22
	%vreg35<def> = LDBZ <fi#2>, 7; mem:LD1[%arrayidx53+1] CPURegs:%vreg35
	%vreg36<def> = AND %vreg35<kill>, %vreg28; CPURegs:%vreg36,%vreg35,%vreg28
	%vreg37<def> = EQI %vreg36<kill>, 0; CPURegs:%vreg37,%vreg36
	JC %vreg37<kill>, <BB#26>; CPURegs:%vreg37
	Jmp <BB#25>
    Successors according to CFG: BB#25(20) BB#26(12)

BB#25: derived from LLVM BB %if.then57
    Predecessors according to CFG: BB#24
	%vreg38<def> = MovGR %ZERO, 6; CPURegs:%vreg38
	%vreg39<def> = LDH <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg39
	%vreg40<def> = XORu %vreg39<kill>, %vreg38<kill>; CPURegs:%vreg40,%vreg39,%vreg38
	STH %vreg40<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg40
    Successors according to CFG: BB#26

BB#26: derived from LLVM BB %if.end61
    Predecessors according to CFG: BB#24 BB#25
	%vreg41<def> = LDHS <fi#5>, 0; mem:LD2[%erry](align=4) CPURegs:%vreg41
	%vreg42<def> = NEQI %vreg41<kill>, 1; CPURegs:%vreg42,%vreg41
	JC %vreg42<kill>, <BB#28>; CPURegs:%vreg42
	Jmp <BB#27>
    Successors according to CFG: BB#27(16) BB#28(16)

BB#27: derived from LLVM BB %if.then65
    Predecessors according to CFG: BB#26
	%vreg43<def> = MovGR %ZERO, 2; CPURegs:%vreg43
	%vreg44<def> = LDH <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg44
	%vreg45<def> = XORu %vreg44<kill>, %vreg43<kill>; CPURegs:%vreg45,%vreg44,%vreg43
	STH %vreg45<kill>, <fi#6>, 0; mem:ST2[%hex](align=4) CPURegs:%vreg45
    Successors according to CFG: BB#28

BB#28: derived from LLVM BB %if.end71
    Predecessors according to CFG: BB#26 BB#27 BB#10 BB#8
	%vreg134<def> = LD <fi#3>, 4; mem:LD4[%z+4] CPURegs:%vreg134
	%vreg135<def> = LD <fi#3>, 0; mem:LD4[%z](align=8) CPURegs:%vreg135
	%vreg136<def> = LDHZ <fi#6>, 0; mem:LD2[%hex](align=4) CPURegs:%vreg136
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg137<def> = COPY %SP; CPURegs:%vreg137
	ST %vreg136<kill>, %vreg137, 8; mem:ST4[<unknown>] CPURegs:%vreg136,%vreg137
	%A0<def> = COPY %vreg135; CPURegs:%vreg135
	%A1<def> = COPY %vreg134; CPURegs:%vreg134
	CALL <ga:@_Atan>, %A0, %A1, <regmask>, %SP<imp-def>, %V0<imp-def>, %V1<imp-def>
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg138<def> = COPY %V0; CPURegs:%vreg138
	%vreg139<def> = COPY %V1; CPURegs:%vreg139
	ST %vreg139, <fi#0>, 4; mem:ST4[%retval+4] CPURegs:%vreg139
	ST %vreg138, <fi#0>, 0; mem:ST4[%retval](align=8) CPURegs:%vreg138
    Successors according to CFG: BB#29

BB#29: derived from LLVM BB %return
    Predecessors according to CFG: BB#17 BB#11 BB#28
	%vreg140<def> = LD <fi#0>, 0; mem:LD4[%retval](align=8) CPURegs:%vreg140
	%vreg141<def> = LD <fi#0>, 4; mem:LD4[%retval+4] CPURegs:%vreg141
	%V0<def> = COPY %vreg140; CPURegs:%vreg140
	%V1<def> = COPY %vreg141; CPURegs:%vreg141
	RetLR %V0<imp-use>, %V1<imp-use>

# End machine code for function atan2.

